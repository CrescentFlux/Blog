# Heap
## åŸºç¡€çŸ¥è¯†
- **å®šä¹‰**ï¼šå †æ˜¯ä¸€ç§ç‰¹æ®Šçš„å®Œå…¨äºŒå‰æ ‘ï¼Œå®ƒæ»¡è¶³å †å±æ€§ï¼šåœ¨æœ€å°å †ä¸­ï¼šçˆ¶èŠ‚ç‚¹çš„å€¼ â‰¤ æ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼ï¼›åœ¨æœ€å¤§å †ä¸­ï¼šçˆ¶èŠ‚ç‚¹çš„å€¼ â‰¥ æ‰€æœ‰å­èŠ‚ç‚¹çš„å€¼
    - ä¸‰å¤§ç‰¹å¾ï¼šå®Œå…¨äºŒå‰æ ‘ç»“æ„ï¼Œå †åºæ€§è´¨ï¼Œæ•°ç»„å­˜å‚¨æ–¹å¼
    - å®Œå…¨äºŒå‰æ ‘ï¼šé™¤äº†æœ€åä¸€å±‚ï¼Œå…¶ä»–å±‚éƒ½æ˜¯æ»¡çš„ï¼Œå¹¶ä¸”æœ€åä¸€å±‚çš„èŠ‚ç‚¹éƒ½å°½é‡é å·¦æ’åˆ—ï¼›å®Œå…¨äºŒå‰æ ‘å¯ä»¥ç”¨æ•°ç»„å®Œç¾è¡¨ç¤ºï¼Œæ²¡æœ‰ç©ºæ´
      - å®Œå…¨äºŒå‰æ ‘åˆ¤æ–­è§„åˆ™ï¼šä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼ŒæŒ‰å±‚çº§ä»å·¦åˆ°å³ç¼–å·å¦‚æœç¼–å·å‡ºç°è·³å·ï¼Œå°±ä¸æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼›ä»å·¦åˆ°å³ã€é€å±‚å¡«å……ã€æ²¡æœ‰ç©ºæ´
- **å †çš„ç±»åˆ«**ï¼š
    - æŒ‰å †æ€§è´¨åˆ†ï¼šæœ€å°å †ï¼šæ ¹èŠ‚ç‚¹æ˜¯æœ€å°å€¼ï¼›æœ€å¤§å †ï¼šæ ¹èŠ‚ç‚¹æ˜¯æœ€å¤§å€¼
    - æŒ‰å®ç°æ–¹å¼åˆ†ï¼šäºŒå‰å †ï¼šæ¯ä¸ªèŠ‚ç‚¹æœ€å¤šä¸¤ä¸ªå­èŠ‚ç‚¹ï¼›äºŒé¡¹å †ï¼šæ›´å¤æ‚çš„åˆå¹¶æ“ä½œï¼›æ–æ³¢é‚£å¥‘å †ï¼šç†è®ºæœ€ä¼˜ä½†å®ç°å¤æ‚

- **å †çš„ä¼˜åŠ¿**ï¼šç”¨æ•°ç»„è€Œä¸ç”¨æ ‘èŠ‚ç‚¹çš„ä¼˜åŠ¿ï¼šå†…å­˜è¿ç»­ï¼Œç¼“å­˜å‹å¥½ï¼›ä¸éœ€è¦æŒ‡é’ˆï¼ŒèŠ‚çœç©ºé—´ï¼›é€šè¿‡æ•°å­¦è®¡ç®—å¿«é€Ÿå®šä½çˆ¶å­èŠ‚ç‚¹
- **æ ¸å¿ƒèƒ½åŠ›**ï¼šå¿«é€Ÿè®¿é—®æœ€å€¼ï¼Œåº”ç”¨ï¼šå½“éœ€è¦é¢‘ç¹è®¿é—®æœ€å€¼ï¼ŒåŒæ—¶æ•°æ®åŠ¨æ€å˜åŒ–æ—¶


## **æ³¨æ„äº‹é¡¹**
1. **æ··æ·†ç‚¹**

|å®Œå…¨äºŒå‰æ ‘ vs æ»¡äºŒå‰æ ‘|å†…å®¹|å…¶ä»–æ··æ·†æ€§è´¨|
---|---|---
|æ»¡äºŒå‰æ ‘ (Full Binary Tree)ï¼š|æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰0ä¸ªæˆ–2ä¸ªå­èŠ‚ç‚¹ï¼Œæ‰€æœ‰å¶å­éƒ½åœ¨åŒä¸€å±‚|æ‰€æœ‰æ»¡äºŒå‰æ ‘éƒ½æ˜¯å®Œå…¨äºŒå‰æ ‘ï¼Œä½†åè¿‡æ¥ä¸æˆç«‹|
|å®Œå…¨äºŒå‰æ ‘ (Complete Binary Tree)ï¼š|é™¤äº†æœ€åä¸€å±‚ï¼Œå…¶ä»–å±‚éƒ½æ˜¯æ»¡çš„ï¼Œæœ€åä¸€å±‚èŠ‚ç‚¹å°½é‡é å·¦|1.åœ¨å †ä¸­ï¼Œå”¯ä¸€çš„è¦æ±‚æ˜¯ï¼šçˆ¶èŠ‚ç‚¹ â‰¤ å­èŠ‚ç‚¹ï¼ˆæœ€å°å †ï¼‰2.å·¦å³å­æ ‘çš„å¤§å°æ˜¯éšæœºçš„ï¼Œä¸éœ€è¦éµå®ˆç‰¹å®šè§„åˆ™;3.å †çš„ç›®æ ‡ï¼šå¿«é€Ÿè®¿é—®æœ€å€¼ï¼Œè€Œä¸æ˜¯å®Œå…¨æ’åº|



2. **ä»£ç å®ç°**
```
//=========================================ğŸ”„å †=============================================//
class MinHeap {
    constructor() {
        this.heap = []; //å †çš„å­˜å‚¨ç»“æ„
    }
    //ğŸ’¡å †çš„å¯¼èˆªç³»ç»Ÿï¼šæ ¸å¿ƒæ€æƒ³ï¼šæ•°ç»„å½“åšæ ‘æ¥æ“ä½œè™½ç„¶å †åœ¨å†…å­˜ä¸­æ˜¯ä¸ªæ™®é€šæ•°ç»„ä½†è¿™äº›å¯¼èˆªæ–¹æ³•è®©æˆ‘ä»¬èƒ½å¤Ÿåƒæ“ä½œæ ‘ä¸€æ ·æ“ä½œæ•°ç»„ï¼šé€šè¿‡æ•°å­¦è®¡ç®—å°±èƒ½æ‰¾åˆ°çˆ¶å­å…³ç³»
    // è·å–çˆ¶èŠ‚ç‚¹ç´¢å¼•
    _parentIndex(index) {
        return Math.floor((index - 1) / 2);
    }
    /*ç¬¬kå±‚çš„ç‰¹æ€§ï¼šç¬¬kå±‚æœ‰ 2^k ä¸ªèŠ‚ç‚¹ï¼Œç¬¬kå±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ç´¢å¼•æ˜¯ï¼š2^k - 1ï¼Œç¬¬kå±‚çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ç´¢å¼•æ˜¯ï¼š2^(k+1) - 2
    åœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œå¦‚æœæ ¹èŠ‚ç‚¹åœ¨ç¬¬0å±‚ï¼Œé‚£ä¹ˆç¬¬kå±‚çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ç´¢å¼•æ˜¯ 2^k - 1"
    å·²çŸ¥ï¼šç¬¬kå±‚æœ‰ 2^k ä¸ªèŠ‚ç‚¹ï¼Œç¬¬kå±‚çš„èŠ‚ç‚¹ç´¢å¼•èŒƒå›´æ˜¯ï¼š[2^k - 1, 2^(k+1) - 2]
    å¯¹äºç´¢å¼•ä¸ºiçš„èŠ‚ç‚¹ï¼šå®ƒä½äºç¬¬kå±‚ï¼Œå…¶ä¸­ k = floor(logâ‚‚(i+1))ï¼Œåœ¨è¯¥å±‚ä¸­çš„ä½ç½®æ˜¯ï¼špos = i - (2^k - 1)
    çˆ¶èŠ‚ç‚¹åœ¨ç¬¬k-1å±‚ï¼Œåœ¨è¯¥å±‚ä¸­çš„ä½ç½®æ˜¯ï¼šfloor(pos / 2)ï¼Œæ‰€ä»¥çˆ¶èŠ‚ç‚¹ç´¢å¼• = (2^(k-1) - 1) + floor(pos / 2)
    parent = floor((i-1)/2)
    2.å­èŠ‚ç‚¹ç´¢å¼•ï¼šå¯¹äºç´¢å¼•ä¸ºiçš„èŠ‚ç‚¹åœ¨ç¬¬kå±‚ï¼šåœ¨è¯¥å±‚ä¸­çš„ä½ç½®ï¼špos = i - (2^k - 1)ï¼Œå·¦å­©å­åœ¨ä¸‹ä¸€å±‚çš„ç¬¬ 2*pos ä¸ªä½ç½®ï¼Œ
    å·¦å­©å­ç´¢å¼• = (2^(k+1) - 1) + 2*poså¾—åˆ°ï¼šleftChild = 2*i + 1
    */
    // è·å–å·¦å­©å­ç´¢å¼•
    _leftChildIndex(index) {
        return 2 * index + 1; 
    }
    
    // è·å–å³å­©å­ç´¢å¼•
    _rightChildIndex(index) {
        return 2 * index + 2;
    }
    
    // äº¤æ¢ä¸¤ä¸ªå…ƒç´ 
    _swap(i, j) {
        [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
    }
    
    // æ’å…¥å…ƒç´ 
    insert(value) {
        this.heap.push(value); // å°†æ–°å€¼æ·»åŠ åˆ°æ•°ç»„æœ«å°¾
        this._bubbleUp(this.heap.length - 1); //ä»æœ€åä¸€ä¸ªä½ç½®å¼€å§‹ä¸Šæµ®
    }
    
    // ä¸Šæµ®æ“ä½œ
    _bubbleUp(index) {
        while (index > 0) {
            const parentIndex = this._parentIndex(index);
            // å¦‚æœçˆ¶èŠ‚ç‚¹å·²ç» <= å½“å‰èŠ‚ç‚¹ï¼Œæ»¡è¶³å †æ€§è´¨ï¼Œé€€å‡º
            if (this.heap[parentIndex] <= this.heap[index]) break; //æ¯”è¾ƒçˆ¶èŠ‚ç‚¹å’Œå½“å‰èŠ‚ç‚¹
            
            // å¦åˆ™äº¤æ¢å¹¶ç»§ç»­ä¸Šæµ®
            this._swap(index, parentIndex); //ä¸çˆ¶èŠ‚ç‚¹äº¤æ¢
            index = parentIndex; // æ›´æ–°å½“å‰ä½ç½®ä¸ºçˆ¶èŠ‚ç‚¹ä½ç½®
        }
    }
    
    // æŸ¥çœ‹æœ€å°å€¼ï¼ˆä¸åˆ é™¤ï¼‰
    peek() {
        return this.heap.length > 0 ? this.heap[0] : null; //æœ€å°å€¼æ€»æ˜¯åœ¨æ ¹èŠ‚ç‚¹ï¼ˆç´¢å¼•0ï¼‰
    }
    
    // è·å–å †å¤§å°
    size() {
        return this.heap[0].length; //è¿”å›å †æ•°ç»„çš„é•¿åº¦
    }
    
    // åˆ¤æ–­å †æ˜¯å¦ä¸ºç©º
    isEmpty() {
        return this.heap.length === 0; //æ£€æŸ¥æ•°ç»„æ˜¯å¦ä¸ºç©º
    }
    // åˆ é™¤å¹¶è¿”å›æœ€å°å€¼
    extractMin() {
        if (this.heap.length === 0) return null; //å †ä¸ºç©ºè¿”å›null
        if (this.heap.length === 1) return this.heap.this.heap.pop(); //åªæœ‰ä¸€ä¸ªå…ƒç´ ç›´æ¥å¼¹å‡º
        
        const min = this.heap[0];
        // ç”¨æœ€åä¸€ä¸ªå…ƒç´ æ›¿æ¢æ ¹èŠ‚ç‚¹
        this.heap[0] = this.heap.pop();//å¼¹å‡ºæœ€åä¸€ä¸ªå…ƒç´ å¹¶æ”¾åˆ°æ ¹ä½ç½®,è¿™é‡Œä¸€æ¬¡æ€§å®Œæˆä¸¤ä¸ªæ“ä½œ:è¿”å›æ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ ,ä»æ•°ç»„ä¸­åˆ é™¤è¿™ä¸ªå…ƒç´ 
        // ä¸‹æ²‰è°ƒæ•´
        this._sinkDown(0); //ä»æ ¹èŠ‚ç‚¹å¼€å§‹ä¸‹æ²‰
        
        return min;
    }
    // ä¸‹æ²‰æ“ä½œ
    _sinkDown(index) {
        const length = this.heap.length;
        
        while (true) {
            const leftChildIndex = this._leftChildIndex(index);
            const rightChildIndex = this._rightChildIndex(index);
            let smallest = index; //å…ˆå‡è®¾å½“å‰èŠ‚ç‚¹æ˜¯æœ€å°çš„
            
            // æ‰¾ä¸‰ä¸ªèŠ‚ç‚¹ä¸­æœ€å°çš„//å †çš„æ€§è´¨è¦æ±‚
            if (leftChildIndex < length && 
                this.heap[leftChildIndex] < this.heap[smallest]) {
                smallest = leftChildIndex; 
            }
            
            if (rightChildIndex < length && 
                this.heap[rightChildIndex] < this.heap[smallest]) {
                smallest = rightChildIndex;
            }
            
            // å¦‚æœå½“å‰èŠ‚ç‚¹å·²ç»æ˜¯æœ€å°çš„ï¼Œé€€å‡ºå¾ªç¯
            if (smallest === index) break; //å †æ€§è´¨å·²æ»¡è¶³
            
            // äº¤æ¢å¹¶ç»§ç»­ä¸‹æ²‰
            this._swap(index, smallest); 
            index = smallest; //æ›´æ–°å½“å‰ä½ç½®
        }
    }
    // ä»æ•°ç»„æ„å»ºå †
    heapify(array) {
        this.heap = [...array]; //å¤åˆ¶ä¼ å…¥çš„æ•°ç»„
        // ä»æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹å¼€å§‹ï¼Œå‘å‰éå†è¿›è¡Œä¸‹æ²‰
        for (let i = Math.floor(this.heap.length / 2); i >= 0; i--) {
            //ä» length/2 å¼€å§‹å¶å­èŠ‚ç‚¹ä¸éœ€è¦ä¸‹æ²‰,æœ€åä¸€ä¸ªéå¶å­èŠ‚ç‚¹ç´¢å¼• = floor(é•¿åº¦/2),ä»åå¾€å‰å¤„ç†ï¼Œä¿è¯å¤„ç†çˆ¶èŠ‚ç‚¹æ—¶ï¼Œå­æ ‘å·²ç»æ˜¯å †
            this._sinkDown(i); //å¯¹æ¯ä¸ªéå¶å­èŠ‚ç‚¹è¿›è¡Œä¸‹æ²‰
        }
    }
    printAndValidate() {
        console.log('=== å †çŠ¶æ€ ===');
        console.log('å †æ•°ç»„:', this.heap);
        console.log('å¤§å°:', this.size());
        console.log('æ˜¯å¦ä¸ºç©º:', this.isEmpty());
        console.log('æœ€å°å€¼:', this.peek());
        
        // éªŒè¯å †æ€§è´¨
        const isValid = this._validateHeap();
        console.log('å †æ€§è´¨éªŒè¯:', isValid ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥');
        
        // æ‰“å°æ ‘ç»“æ„
        this.printTree();
        
        return isValid;
    }
    
    _validateHeap() {
        for (let i = 0; i < this.heap.length; i++) {
            const left = this._leftChildIndex(i);
            const right = this._rightChildIndex(i);
            
            if (left < this.heap.length && this.heap[i] > this.heap[left]) {
                console.log(`âŒ è¿åå †æ€§è´¨: çˆ¶èŠ‚ç‚¹[${i}]=${this.heap[i]} > å·¦å­©å­[${left}]=${this.heap[left]}`);
                return false;
            }
            
            if (right < this.heap.length && this.heap[i] > this.heap[right]) {
                console.log(`âŒ è¿åå †æ€§è´¨: çˆ¶èŠ‚ç‚¹[${i}]=${this.heap[i]} > å³å­©å­[${right}]=${this.heap[right]}`);
                return false;
            }
        }
        return true;
    }
    // æ‰“å°å †ï¼ˆè°ƒè¯•ç”¨ï¼‰
    print() {
        console.log('MinHeap:', this.heap); //æ‰“å°å †æ•°ç»„}
       // æ‰“å°æ ‘ç»“æ„
    }
    printTree() {
        if (this.heap.length === 0) {
            console.log('å †ä¸ºç©º');
            return;
        }
        
        let result = '';
        const levels = Math.floor(Math.log2(this.heap.length)) + 1;
        
        for (let i = 0; i < levels; i++) {
            const start = Math.pow(2, i) - 1;
            const end = Math.min(Math.pow(2, i + 1) - 1, this.heap.length);
            const levelNodes = this.heap.slice(start, end);
            
            // æ·»åŠ ç¼©è¿›
            const indent = ' '.repeat(Math.pow(2, levels - i - 1) - 1);
            result += indent + levelNodes.join(' ') + '\n';
            
            // æ·»åŠ è¿æ¥çº¿ï¼ˆé™¤äº†æœ€åä¸€å±‚ï¼‰
            if (i < levels - 1) {
                const lineIndent = ' '.repeat(Math.pow(2, levels - i - 2) - 1);
                const lines = '/\\ '.repeat(levelNodes.length).trim();
                result += lineIndent + lines + '\n';
            }
        }
        
        console.log('å †çš„æ ‘ç»“æ„:');
        console.log(result);
    }
    printTreeDetailed() {
        if (this.heap.length === 0) {
            console.log('å †ä¸ºç©º');
            return;
        }
        
        console.log('å †çš„æ ‘ç»“æ„:');
        this._printNode(0, '', true);
    }
    
    _printNode(index, prefix, isLeft) {
        if (index >= this.heap.length) return;
        
        // æ‰“å°å½“å‰èŠ‚ç‚¹
        console.log(prefix + (isLeft ? 'â”œâ”€â”€ ' : 'â””â”€â”€ ') + this.heap[index]);
        
        // å‡†å¤‡æ–°çš„å‰ç¼€
        const newPrefix = prefix + (isLeft ? 'â”‚   ' : '    ');
        
        // é€’å½’æ‰“å°å·¦å³å­æ ‘
        const leftIndex = this._leftChildIndex(index);
        const rightIndex = this._rightChildIndex(index);
        
        if (leftIndex < this.heap.length) {
            this._printNode(leftIndex, newPrefix, true);
        }
        if (rightIndex < this.heap.length) {
            this._printNode(rightIndex, newPrefix, false);
        }
    }}
    


// æµ‹è¯•å †çš„åŠŸèƒ½
function testMinHeap() {
    const heap = new MinHeap();
    
    // æµ‹è¯•æ’å…¥
    heap.insert(5);
    heap.insert(3);
    heap.insert(8);
    heap.insert(1);
    heap.insert(10);
    heap.printTree();
    heap.printTreeDetailed();
    console.log('æ’å…¥åå †:', heap.heap);
    console.log('æœ€å°å€¼:', heap.peek()); //åº”è¯¥è¾“å‡º1ä½†ä¸åˆ é™¤
    
    // æµ‹è¯•åˆ é™¤
    console.log('åˆ é™¤çš„å€¼:', heap.extractMin()); //åº”è¯¥è¾“å‡º1
    console.log('åˆ é™¤åå †:', heap.heap);
    
    // æµ‹è¯•å †åŒ–
    const heap2 = new MinHeap();
    heap2.heapify([15, 10, 20, 5, 8, 25]);
    console.log('å †åŒ–å:', heap2.heap);
    console.log('å¤§å°:', heap2.size());
    heap2.printTree();
    heap2.printTreeDetailed();
}
// å¢å¼ºçš„æµ‹è¯•å‡½æ•°ï¼Œæ¯ä¸€æ­¥éƒ½æ‰“å°å †çŠ¶æ€
function testMinHeapWithVisualization() {
    console.log('=== å¼€å§‹å †æµ‹è¯• ===\n');
    
    const heap = new MinHeap();
    
    // æµ‹è¯•æ’å…¥æ“ä½œ
    console.log('1. æ’å…¥å…ƒç´  5');
    heap.insert(5);
    heap.printAndValidate();
    heap.printTreeDetailed();
    console.log('\n2. æ’å…¥å…ƒç´  3');
    heap.insert(3);
    heap.printAndValidate();
    heap.printTreeDetailed();
    console.log('\n3. æ’å…¥å…ƒç´  8');
    heap.insert(8);
    heap.printAndValidate();
    heap.printTreeDetailed();
    console.log('\n4. æ’å…¥å…ƒç´  1');
    heap.insert(1);
    heap.printAndValidate();
    heap.printTreeDetailed();
    console.log('\n5. æ’å…¥å…ƒç´  10');
    heap.insert(10);
    heap.printAndValidate();
    heap.printTreeDetailed();
    // æµ‹è¯•æŸ¥çœ‹æœ€å°å€¼ï¼ˆä¸åˆ é™¤ï¼‰
    console.log('\n6. æŸ¥çœ‹æœ€å°å€¼ï¼ˆä¸åˆ é™¤ï¼‰');
    console.log('å½“å‰æœ€å°å€¼:', heap.peek());
    heap.printAndValidate(); // å †åº”è¯¥ä¿æŒä¸å˜
    heap.printTreeDetailed();
    // æµ‹è¯•åˆ é™¤æ“ä½œ
    console.log('\n7. ç¬¬ä¸€æ¬¡åˆ é™¤æœ€å°å€¼');
    const removed1 = heap.extractMin();
    console.log('åˆ é™¤çš„å€¼:', removed1);
    heap.printAndValidate();
    heap.printTreeDetailed();
    console.log('\n8. ç¬¬äºŒæ¬¡åˆ é™¤æœ€å°å€¼');
    const removed2 = heap.extractMin();
    console.log('åˆ é™¤çš„å€¼:', removed2);
    heap.printAndValidate();
    heap.printTreeDetailed();
    console.log('\n9. ç¬¬ä¸‰æ¬¡åˆ é™¤æœ€å°å€¼');
    const removed3 = heap.extractMin();
    console.log('åˆ é™¤çš„å€¼:', removed3);
    heap.printAndValidate();
    heap.printTreeDetailed();
    // æµ‹è¯•å †åŒ–
    console.log('\n=== æµ‹è¯•å †åŒ–åŠŸèƒ½ ===');
    const heap2 = new MinHeap();
    console.log('å †åŒ–æ•°ç»„: [15, 10, 20, 5, 8, 25]');
    heap2.heapify([15, 10, 20, 5, 8, 25]);
    heap2.printAndValidate();
    heap2.printTreeDetailed();
    console.log('\nå †åŒ–ååˆ é™¤æœ€å°å€¼');
    const removedFromHeap2 = heap2.extractMin();
    console.log('åˆ é™¤çš„å€¼:', removedFromHeap2);
    heap2.printAndValidate();
    heap2.printTreeDetailed();
}
// è¿è¡Œæµ‹è¯•
testMinHeap();
// è¿è¡Œå¢å¼ºæµ‹è¯•
testMinHeapWithVisualization();
//=======================================ğŸ”„dijkstra======================================//
function dijkstraBasic(graph, start) {
    // åˆå§‹åŒ–è·ç¦»è¡¨ï¼Œè®°å½•ä»èµ·ç‚¹åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    const distances = {};
    // åˆå§‹åŒ–å·²è®¿é—®é›†åˆï¼Œè®°å½•å·²ç»ç¡®å®šæœ€çŸ­è·¯å¾„çš„èŠ‚ç‚¹
    const visited = new Set();
    // åˆå§‹åŒ–å‰é©±èŠ‚ç‚¹è¡¨ï¼Œç”¨äºå›æº¯è·¯å¾„
    const previous = {};
    // è·å–æ‰€æœ‰èŠ‚ç‚¹
    const nodes = Object.keys(graph);
    // æ­¥éª¤1: åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹çš„è·ç¦»ä¸ºæ— ç©·å¤§
    for (const node of nodes) {
        distances[node] = Infinity; 
        previous[node] = null;
    }
    // èµ·ç‚¹çš„è·ç¦»è®¾ä¸º0
    distances[start] = 0; 
    // ä¸»å¾ªç¯ï¼šå½“è¿˜æœ‰èŠ‚ç‚¹æœªè®¿é—®æ—¶ç»§ç»­
    while (visited.size < nodes.length) {
        // æ­¥éª¤2: ä»æœªè®¿é—®èŠ‚ç‚¹ä¸­æ‰¾åˆ°è·ç¦»æœ€è¿‘çš„èŠ‚ç‚¹
        let currentNode = null;
        let minDistance = Infinity;
        
        for (const node in distances) {
            if (!visited.has(node) && distances[node] < minDistance) {
                minDistance = distances[node];
                currentNode = node;
            }
        }
        if (currentNode === null) break;
        // æ ‡è®°å½“å‰èŠ‚ç‚¹ä¸ºå·²è®¿é—®
        visited.add(currentNode);
        // æ­¥éª¤3: æ›´æ–°æ‰€æœ‰é‚»å±…çš„è·ç¦»
        for (const [neighbor, weight] of graph[currentNode]) {
            if (!visited.has(neighbor)) {
                // è®¡ç®—ç»è¿‡å½“å‰èŠ‚ç‚¹åˆ°è¾¾é‚»å±…çš„æ–°è·ç¦»
                const newDistance = distances[currentNode] + weight; 
                // å¦‚æœæ–°è·ç¦»æ›´çŸ­ï¼Œåˆ™æ›´æ–°
                if (newDistance < distances[neighbor]) {
                    distances[neighbor] = newDistance;
                    previous[neighbor] = currentNode; 
                }
            }
        }
    }
    return { distances, previous };
}
class PriorityQueue {
    constructor() {
        this.nodes = []; // å­˜å‚¨èŠ‚ç‚¹å’Œå®ƒä»¬çš„ä¼˜å…ˆçº§ï¼ˆè·ç¦»ï¼‰
    }
    
    enqueue(node, priority) {
        this.nodes.push({ node, priority });
        this.nodes.sort((a, b) =>  a.priority - b.priority); //æŒ‰ä¼˜å…ˆçº§å‡åºæ’åºï¼Œè®©æœ€å°çš„åœ¨æœ€å‰é¢
    }
    
    dequeue() {
        return this.nodes.shift().node;// å–å‡ºä¼˜å…ˆçº§æœ€é«˜çš„ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ ï¼‰
    }
    
    isEmpty() {
        return this.nodes.length === 0; //æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    }
}
function dijkstraWithPQ(graph, start) {
    //ğŸ‘‰ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ä¼˜åŒ–ç‰ˆçš„ Dijkstra ç®—æ³•ï¼Œç”¨æ›´é«˜æ•ˆçš„æ–¹å¼æ‰¾åˆ°ä»èµ·ç‚¹åˆ°æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„,ç”¨ä¼˜å…ˆé˜Ÿåˆ—çš„æ•°æ®ç»“æ„æ›¿ä»£äº†è€—æ—¶çš„çº¿æ€§æœç´¢ï¼Œè®©ç®—æ³•åœ¨å¤§å‹å›¾ä¸­è¿è¡Œå¾—æ›´å¿«
    // åˆå§‹åŒ–æ•°æ®ç»“æ„
    const distances = {}; // è®°å½•åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»
    const previous = {}; // è®°å½•è·¯å¾„å›æº¯ä¿¡æ¯
    const pq = new PriorityQueue(); // ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå¸®æˆ‘ä»¬å¿«é€Ÿæ‰¾åˆ°æœ€è¿‘èŠ‚ç‚¹
    
    // åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹
    for (const node in graph) {
        distances[node] = node === start ? 0 : Infinity;// èµ·ç‚¹è·ç¦»ä¸º0ï¼Œå…¶ä»–æ— ç©·å¤§
        previous[node] = null; //è¿˜æ²¡æœ‰å‰é©±èŠ‚ç‚¹
        if (node === start) {
            pq.enqueue(node, 0); //èµ·ç‚¹å…¥é˜Ÿï¼Œä¼˜å…ˆçº§ä¸º0
        }
    }
    //ä¸»å¾ªç¯é˜¶æ®µ
    while (!pq.isEmpty()) {
        const currentNode = pq.dequeue();
        
        for (const [neighbor, weight] of graph[currentNode]) {
            const newDistance = distances[currentNode] + weight;
            
            // æ ¸å¿ƒé€»è¾‘ï¼šå¦‚æœæ‰¾åˆ°æ›´çŸ­è·¯å¾„
            if (newDistance < distances[neighbor]) { //æ–°è·ç¦»æ¯”å·²çŸ¥è·ç¦»æ›´çŸ­
                distances[neighbor] = newDistance;
                previous[neighbor] = currentNode;
                // å°†é‚»å±…åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—
                pq.enqueue(neighbor, newDistance); // é‚»å±…å…¥é˜Ÿï¼Œä¼˜å…ˆçº§ä¸ºæ–°è·ç¦»
            }
        }
    }
    
    return { distances, previous };
}
function getShortestPath(previous, endNode) {//ä»ç»“æœä¸­é‡æ„å‡ºå®Œæ•´è·¯å¾„çš„å·¥å…·,æŠŠ Dijkstra ç®—æ³•ç”Ÿæˆçš„"å‰é©±èŠ‚ç‚¹è¡¨"è½¬æ¢æˆäººç±»èƒ½çœ‹æ‡‚çš„å®Œæ•´è·¯å¾„
    const path = [];// ç”¨æ¥å­˜å‚¨æœ€ç»ˆçš„è·¯å¾„
    let currentNode = endNode;// ä»ç»ˆç‚¹å¼€å§‹å›æº¯
    
    // ä»ç»ˆç‚¹å›æº¯åˆ°èµ·ç‚¹
    while (currentNode !== null) { // å½“å‰èŠ‚ç‚¹ä¸ä¸ºç©ºæ—¶ç»§ç»­
        path.unshift(currentNode); // å°†å½“å‰èŠ‚ç‚¹æ·»åŠ åˆ°è·¯å¾„å¼€å¤´
        currentNode = previous[currentNode]; // ç§»åŠ¨åˆ°å‰ä¸€ä¸ªèŠ‚ç‚¹
    }
    
    return path;
}
/*
ğŸ‘‰åŠ æƒå›¾å°±æ˜¯åœ¨æ™®é€šçš„å›¾åŸºç¡€ä¸Šï¼Œç»™æ¯æ¡è¾¹éƒ½èµ‹äºˆä¸€ä¸ª"æƒé‡"ï¼ˆæ•°å€¼ï¼‰çš„å›¾ï¼ŒDijkstraç®—æ³•ä¸ºåŠ æƒå›¾è®¾è®¡ã€‚
æ™®é€šå›¾ï¼ˆæ— æƒé‡ï¼‰ï¼šåªè®°å½•è¿æ¥å…³ç³»ï¼›åŠ æƒå›¾ï¼šè®°å½•è¿æ¥å…³ç³»å’Œæƒé‡ï¼›
åŠ æƒå›¾çš„ä¸‰ç§ç±»å‹ï¼šè·ç¦»/æˆæœ¬æƒé‡ï¼ˆæ­£æ•°ï¼‰æ”¶ç›Š/å®¹é‡æƒé‡ï¼ˆæ­£æ•°ï¼‰æ··åˆæƒé‡ï¼ˆå¯èƒ½æœ‰è´Ÿæ•°ï¼‰
Dijkstra ç®—æ³•ä¸èƒ½å¤„ç†è´Ÿæƒé‡çš„è¾¹ï¼Œè´Ÿæƒè¾¹ä¼šç ´å"ä¸€æ—¦ç¡®è®¤å°±æ˜¯æœ€çŸ­è·¯å¾„"çš„å‰æ  
ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼šåŸºç¡€ç‰ˆæœ¬ï¼šO(VÂ²)ï¼Œä¼˜å…ˆé˜Ÿåˆ—ç‰ˆæœ¬ï¼šO((V+E) log V)
ç®—æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯è´ªå¿ƒç®—æ³•ï¼Œæ¯æ¬¡éƒ½æ˜¯é€‰æ‹©æœ€è¿‘çš„èŠ‚ç‚¹   
è¯¥ç®—æ³•ä¿è¯æ‰¾åˆ°çš„æ˜¯å•æºæœ€çŸ­è·¯å¾„ï¼Œå®ƒä»å•ä¸ªèµ·ç‚¹å‡ºå‘ï¼Œæ‰¾åˆ°åˆ°æ‰€æœ‰å…¶ä»–èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„
ğŸ‘‰åŒæ ·çš„é€»è¾‘é€‚ç”¨äºï¼šåœ°å›¾å¯¼èˆªï¼Œç½‘ç»œè·¯ç”±ï¼Œä»»åŠ¡è°ƒåº¦ï¼Œæ¸¸æˆAIå¯»è·¯
*/

// ä½¿ç”¨ç¤ºä¾‹
const graph = {
    'A': [['B', 4], ['C', 2]],
    'B': [['A', 4], ['C', 1], ['D', 5]],
    'C': [['A', 2], ['B', 1], ['D', 8], ['E', 10]],
    'D': [['B', 5], ['C', 8], ['E', 2]],
    'E': [['C', 10], ['D', 2]]
};

const result = dijkstraBasic(graph, 'A');
const pathToE = getShortestPath(result.previous, 'E');

console.log('æœ€çŸ­è·¯å¾„:', pathToE.join(' -> ')); // åº”è¯¥è¾“å‡º: A -> C -> B -> D -> E
console.log('æ€»è·ç¦»:', result.distances['E']); // åº”è¯¥è¾“å‡º: 10
// æµ‹è¯•
const testGraph = {//å®šä¹‰å›¾çš„é‚»æ¥è¡¨è¡¨ç¤ºæ³•ï¼Œè¡¨ç¤ºä¸€ä¸ªå›¾ç»“æ„ï¼Œæ¯ä¸ªèŠ‚ç‚¹éƒ½è®°å½•å®ƒèƒ½ç›´æ¥åˆ°è¾¾çš„é‚»å±…å’Œè·ç¦»//ä¼˜åŠ¿ï¼šèŠ‚çœç©ºé—´ï¼Œåªå­˜å‚¨å®é™…å­˜åœ¨çš„è¿æ¥
    'S': [['A', 7], ['B', 2], ['C', 3]],
    'A': [['S', 7], ['B', 3], ['D', 4]],
    'B': [['S', 2], ['A', 3], ['D', 4], ['H', 1]],
    'C': [['S', 3], ['L', 2]],
    'D': [['A', 4], ['B', 4], ['F', 5]],
    'H': [['B', 1], ['F', 3], ['G', 2]],
    'F': [['D', 5], ['H', 3]],
    'G': [['H', 2], ['E', 2]],
    'L': [['C', 2], ['I', 4], ['J', 4]],
    'I': [['L', 4], ['J', 6], ['K', 4]],
    'J': [['L', 4], ['I', 6], ['K', 4]],
    'K': [['I', 4], ['J', 4], ['E', 5]],
    'E': [['G', 2], ['K', 5]]
};

const testResult = dijkstraBasic(testGraph, 'S');
console.log('Såˆ°Eçš„æœ€çŸ­è·¯å¾„:', getShortestPath(testResult.previous, 'E').join(' -> '));
console.log('è·ç¦»:', testResult.distances['E']);
//=======================================ğŸ”„ä¼˜åŒ–Dijkstra====================================//
class PriorityQueue {
    //ğŸ“œæ²¡æœ‰å †ï¼šæ¯æ¬¡æ‰¾æœ€å°å€¼éœ€è¦æ£€æŸ¥æ‰€æœ‰èŠ‚ç‚¹ï¼Œæœ‰å †ï¼šç›´æ¥è·å–å †é¡¶å°±æ˜¯æœ€å°å€¼
    constructor() {
        this.heap = [];
    }
    //ä¿®æ”¹å †ï¼Œä½¿å…¶èƒ½å­˜å‚¨èŠ‚ç‚¹å’Œè·ç¦»
    // æ’å…¥èŠ‚ç‚¹å’Œè·ç¦»
    enqueue(node, distance) {
        this.heap.push({ node, distance });
        this._bubbleUp(this.heap.length - 1);
        /*å †æ’å…¥æ“ä½œçš„æ ¸å¿ƒï¼Œä»å †çš„æœ€åä¸€ä¸ªä½ç½®å¼€å§‹ä¸Šæµ®è°ƒæ•´ï¼Œè¯·ä»æ–°æ’å…¥çš„å…ƒç´ ä½ç½®å¼€å§‹ï¼Œå‘ä¸Šæ£€æŸ¥å¹¶è°ƒæ•´ï¼Œç›´åˆ°å †æ€§è´¨æ¢å¤
        this.heap.length - 1æ–°å…ƒç´ 1çš„ç´¢å¼•
        this._bubbleUp(3)ï¼šä»ç´¢å¼•3ï¼ˆæ–°å…ƒç´ 1ï¼‰å¼€å§‹ï¼Œä¸æ–­ä¸çˆ¶èŠ‚ç‚¹æ¯”è¾ƒï¼Œå¦‚æœè¿åå †æ€§è´¨å°±äº¤æ¢ï¼Œç›´åˆ°æ»¡è¶³å †æ€§è´¨
        */
    }
    
    // åˆ é™¤å¹¶è¿”å›è·ç¦»æœ€å°çš„èŠ‚ç‚¹
    dequeue() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();
        
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._sinkDown(0);
        return min;
    }
    
    // æŸ¥çœ‹æœ€å°è·ç¦»èŠ‚ç‚¹ï¼ˆä¸åˆ é™¤ï¼‰
    peek() {
        return this.heap[0] || null;
    }
    
    isEmpty() {
        return this.heap.length === 0;
    }
    
    // å †è°ƒæ•´æ–¹æ³•ï¼ˆéœ€è¦ä¿®æ”¹æ¯”è¾ƒé€»è¾‘ï¼‰
    _bubbleUp(index) {
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            // æ¯”è¾ƒdistanceè€Œä¸æ˜¯ç›´æ¥æ¯”è¾ƒå€¼
            if (this.heap[parentIndex].distance <= this.heap[index].distance) break;
            
            [this.heap[parentIndex], this.heap[index]] = 
            [this.heap[index], this.heap[parentIndex]];
            index = parentIndex;
        }
    }
    
    _sinkDown(index) {
        const length = this.heap.length;
        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let smallest = index;
            if (leftChildIndex < length && 
                this.heap[leftChildIndex].distance < this.heap[smallest].distance) {
                smallest = leftChildIndex;
            }
            
            if (rightChildIndex < length && 
                this.heap[rightChildIndex].distance < this.heap[smallest].distance) {
                smallest = rightChildIndex;
            }
            
            if (smallest === index) break;
            // è¿™é‡Œï¼æ²¡æœ‰è°ƒç”¨ _swap æ–¹æ³•ï¼Œè€Œæ˜¯ç›´æ¥å†™äº¤æ¢é€»è¾‘
            [this.heap[index], this.heap[smallest]] = 
            [this.heap[smallest], this.heap[index]];
            index = smallest;
        }
    }
}
//ç”¨ä¼˜å…ˆé˜Ÿåˆ—å®ç°Dijkstra
function dijkstraWithHeap(graph, start) {
    // åˆå§‹åŒ–æ•°æ®ç»“æ„// åˆå§‹åŒ–: O(V)
    const distances = {};
    const previous = {};
    const pq = new PriorityQueue();
    
    // 1. åˆå§‹åŒ–æ‰€æœ‰èŠ‚ç‚¹çš„è·ç¦»
    for (const node in graph) {
        distances[node] = node === start ? 0 : Infinity;
        previous[node] = null;
    }
    // 2. èµ·ç‚¹å…¥é˜Ÿ
    pq.enqueue(start, 0);
    // 3. ä¸»å¾ªç¯
    while (!pq.isEmpty()) {// å¾ªç¯ V æ¬¡
        // è·å–å½“å‰è·ç¦»æœ€å°çš„èŠ‚ç‚¹
        const { node: currentNode, distance: currentDistance } = pq.dequeue();// O(log V)
        // å¦‚æœå½“å‰è·ç¦»å¤§äºå·²çŸ¥æœ€çŸ­è·ç¦»ï¼Œè·³è¿‡ï¼ˆæ‡’åˆ é™¤ï¼‰
        if (currentDistance > distances[currentNode]) continue;
        // 4. éå†æ‰€æœ‰é‚»å±…
        for (const [neighbor, weight] of graph[currentNode]) {// æ€»å…± E æ¬¡å¾ªç¯
            const newDistance = distances[currentNode] + weight;
            // 5. å¦‚æœæ‰¾åˆ°æ›´çŸ­è·¯å¾„
            if (newDistance < distances[neighbor]) {
                distances[neighbor] = newDistance;
                previous[neighbor] = currentNode;
                // å°†é‚»å±…åŠ å…¥ä¼˜å…ˆé˜Ÿåˆ—// æ›´æ–°å’Œå…¥é˜Ÿ: O(log V)
                pq.enqueue(neighbor, newDistance);
            }
        }
    }
    return { distances, previous };
/*
æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šå‡ºé˜Ÿä¸€æ¬¡
while (!pq.isEmpty()) {           // å¾ªç¯ V æ¬¡
    const current = pq.dequeue(); // O(log V) Ã— V = O(V log V)
}
æ¯æ¡è¾¹æ£€æŸ¥ä¸€æ¬¡ â†’ E æ¬¡é‚»å±…éå†
for (const [neighbor, weight] of graph[currentNode]) {
    // å¯èƒ½æ‰§è¡Œ enqueue: O(log V) Ã— E = O(E log V)
    pq.enqueue(neighbor, newDistance);
}
åˆå¹¶æ—¶é—´å¤æ‚åº¦
æ€»æ—¶é—´ = Væ¬¡dequeue + Eæ¬¡enqueue
       = O(V log V) + O(E log V)
       = O((V + E) log V)
å †çš„é«˜åº¦æ˜¯ log Vï¼Œæ¯ä¸ªå †æ“ä½œï¼ˆæ’å…¥ã€åˆ é™¤ï¼‰éƒ½éœ€è¦ä»æ ¹åˆ°å¶å­çš„è·¯å¾„//Vï¼šæ¯ä¸ªèŠ‚ç‚¹å¤„ç†ä¸€æ¬¡ï¼ŒEï¼šæ¯æ¡è¾¹æ£€æŸ¥ä¸€æ¬¡
æ‡’åˆ é™¤çš„å½±å“ï¼šè¿™ç¡®ä¿æ¯ä¸ªèŠ‚ç‚¹æœ€å¤šå‡ºé˜Ÿä¸€æ¬¡ï¼Œå³ä½¿å®ƒè¢«å¤šæ¬¡å…¥é˜Ÿif (currentDistance > distances[currentNode]) continue;
åŸºç¡€ç‰ˆæœ¬ï¼ˆæ²¡æœ‰å †ï¼‰ï¼šæ¯æ¬¡æ‰¾æœ€å°å€¼éœ€è¦éå†æ‰€æœ‰èŠ‚ç‚¹ï¼Œæ€»æ—¶é—´: Væ¬¡å¾ªç¯ Ã— Væ¬¡æŸ¥æ‰¾ = O(VÂ²)
*/
}
// æµ‹è¯•å›¾
const graph2 = {
    'A': [['B', 4], ['C', 2]],
    'B': [['A', 4], ['C', 1], ['D', 5]],
    'C': [['A', 2], ['B', 1], ['D', 8], ['E', 10]],
    'D': [['B', 5], ['C', 8], ['E', 2]],
    'E': [['C', 10], ['D', 2]]
};
// è·¯å¾„é‡æ„å‡½æ•°
function getShortestPath(previous, endNode) {
    const path = [];
    let currentNode = endNode;
    
    while (currentNode !== null) {
        path.unshift(currentNode);
        currentNode = previous[currentNode];
    }
    
    return path;
}

// æµ‹è¯•ä¼˜åŒ–åçš„Dijkstra
function testDijkstraWithHeap() {
    console.log('=== ä½¿ç”¨å †ä¼˜åŒ–çš„Dijkstraç®—æ³• ===\n');
    
    const startNode = 'A';
    const { distances, previous } = dijkstraWithHeap(graph2, startNode);
    
    console.log('ä»èµ·ç‚¹', startNode, 'åˆ°å„èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»:');
    for (const node in distances) {
        console.log(`  åˆ° ${node}: ${distances[node]}`);
    }
    
    console.log('\næœ€çŸ­è·¯å¾„è¯¦æƒ…:');
    for (const node in distances) {
        if (node !== startNode) {
            const path = getShortestPath(previous, node);
            console.log(`  ${startNode} -> ${node}: ${path.join(' â†’ ')} (è·ç¦»: ${distances[node]})`);
        }
    }
    
    // æ€§èƒ½å¯¹æ¯”
    console.log('\n=== ğŸ’«æ€§èƒ½ä¼˜åŠ¿ ===');
    console.log('æ²¡æœ‰å †: éœ€è¦ VÂ² æ¬¡æ¯”è¾ƒ');
    console.log('æœ‰å †: åªéœ€è¦ (V+E) log V æ¬¡æ“ä½œ');
    console.log('å¯¹äºå¤§å‹å›¾ï¼Œæ€§èƒ½æå‡æ˜¾è‘—ï¼');
}

// è¿è¡Œæµ‹è¯•
testDijkstraWithHeap();
```












