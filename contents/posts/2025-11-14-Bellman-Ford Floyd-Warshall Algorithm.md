
# Bellman-Ford   Floyd-Warshall  Algorithm
## åŸºç¡€çŸ¥è¯†

- Bellman-Ford ç®—æ³•
   - å®šä¹‰ï¼šç”¨äºè®¡ç®—å•æºæœ€çŸ­è·¯å¾„çš„åŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œèƒ½å¤Ÿå¤„ç†åŒ…å«è´Ÿæƒè¾¹çš„å›¾ï¼Œå¹¶èƒ½æ£€æµ‹è´Ÿæƒç¯çš„å­˜åœ¨ã€‚

- Floyd-Warshall ç®—æ³•
   - å®šä¹‰ï¼šæ˜¯ä¸€ç§ç”¨äºè®¡ç®—æ‰€æœ‰ç‚¹å¯¹æœ€çŸ­è·¯å¾„çš„åŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œé€šè¿‡è€ƒè™‘æ‰€æœ‰å¯èƒ½çš„ä¸­é—´èŠ‚ç‚¹ï¼Œç³»ç»Ÿåœ°ä¼˜åŒ–æ¯å¯¹é¡¶ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚



## æ³¨æ„äº‹é¡¹
1. **æ··æ·†ç‚¹**
- **ç®—æ³•å¯¹æ¯”**

|ç‰¹æ€§	|Dijkstra	|Bellman-Ford|	Floyd-Warshall|
---|---|---|---
|é—®é¢˜ç±»å‹|	å•æºæœ€çŸ­è·¯å¾„|	å•æºæœ€çŸ­è·¯å¾„(åªèƒ½çŸ¥é“å…·ä½“æŸä¸ªç‚¹åˆ°æ‰€æœ‰ç‚¹çš„è·ç¦»)	|å…¨æºæœ€çŸ­è·¯å¾„(ä»»æ„ä¸¤ç‚¹é—´çš„æœ€çŸ­è·ç¦»)|
|æƒé‡è¦æ±‚|	éè´Ÿæƒè¾¹	|ä»»æ„æƒé‡	|ä»»æ„æƒé‡|
|æ ¸å¿ƒæ€æƒ³|	è´ªå¿ƒç®—æ³•|	åŠ¨æ€è§„åˆ’|	åŠ¨æ€è§„åˆ’|
|æ ¸å¿ƒä»·å€¼|	é«˜æ•ˆå¿«é€Ÿ|	è´Ÿæƒç¯æ£€æµ‹|	å…¨å±€è§†å›¾|
|åº”ç”¨åœºæ™¯|åœ°å›¾å¯¼èˆª - ä»Aç‚¹åˆ°æ‰€æœ‰ç‚¹|é‡‘èå¥—åˆ©æ£€æµ‹ - å¯èƒ½å­˜åœ¨è´Ÿæƒç¯|ç½‘ç»œåŸºç¡€è®¾æ–½ - éœ€è¦å…¨è¿æ¥ä¿¡æ¯|



2. **ä»£ç å®ç°**
```
//=================================ğŸ”„bellmanFord=============================//
function bellmanFord(graph, start) {
    const { vertices, edges } = graph;
    const dist = {};
    const prev = {}; // ç”¨äºè®°å½•è·¯å¾„
    // åˆå§‹åŒ–: O(V)
    // 1. åˆå§‹åŒ–è·ç¦»æ•°ç»„
    for (let vertex of vertices) {
        dist[vertex] = vertex === start ? 0: Infinity;// èµ·ç‚¹ä¸º0ï¼Œå…¶ä»–ä¸ºæ— ç©·å¤§
        prev[vertex] = null;
    }
    // æ ¸å¿ƒéƒ¨åˆ†: V-1 è½®æ¾å¼›
    // 2. è¿›è¡ŒV-1è½®æ“ä½œ
    for (let i = 0; i < vertices.length - 1; i++) {// O(V)
         // V-1 è½®ï¼ŒVæ˜¯é¡¶ç‚¹æ•°ï¼›å¦‚æœç”¨Vä»£è¡¨é¡¶ç‚¹æ•°ï¼Œéœ€è¦å…ˆå®šä¹‰ const V = vertices.length;
        let updated = false;
        
        for (let edge of edges) { // O(E)
            const { u, v, weight } = edge;//weight-ä»uåˆ°vè¿™æ®µè·¯çš„è¿è¾“æˆæœ¬;uï¼šè¿™æ¡è·¯ä»å“ªå„¿å¼€å§‹;vï¼šè¿™æ¡è·¯åˆ°å“ªå„¿ç»“æŸ 
            
            // æ“ä½œï¼šå¦‚æœæ‰¾åˆ°æ›´çŸ­çš„è·¯å¾„å°±æ›´æ–°
            if (dist[u] + weight < dist[v]) {// O(1)
                /*
                ğŸ‘‰æ¯”è¾ƒæ–°çš„è·¯å¾„æˆæœ¬å’Œå½“å‰çš„æœ€çŸ­è·ç¦»//æ–°æ–¹æ¡ˆ vs å½“å‰æœ€ä½³æ–¹æ¡ˆ
                ç›®æ ‡ï¼š â€œä»èµ·ç‚¹ S åˆ°ç»ˆç‚¹ vâ€çš„å®Œæ•´è·¯å¾„;
                dist[u] + weight = æ–°å‘ç°çš„è·¯å¾„çš„æˆæœ¬;dist[u]:ä» S åˆ° u çš„æœ€ä¼˜è·¯å¾„å·²ç»ç¡®ä¿å®ƒæ˜¯ä» S åˆ° u çš„æœ€ä½³æ–¹æ¡ˆ
                weightï¼šä» u åˆ° v çš„ç›´æ¥è¿æ¥ï¼›å…³é”®ç‰¹æ€§ï¼š å®ƒåªå…³å¿ƒ u å’Œ v è¿™ä¸¤ä¸ªç‚¹ä¹‹é—´çš„ç›´æ¥å…³ç³»ï¼›å¾—åˆ°dist[u] + weightï¼ˆä»Såˆ°vçš„æ–°å€™é€‰è·¯å¾„ï¼‰
                ç°æœ‰æœ€ä¼˜æ–¹æ¡ˆè·¯å¾„dist[v]æ¯”è¾ƒ
                ğŸ‘‰åŠ¨æ€è§„åˆ’çš„æœ€ä¼˜å­ç»“æ„â€”â€”å¤§é—®é¢˜çš„æœ€ä¼˜è§£åŒ…å«ç€å°é—®é¢˜çš„æœ€ä¼˜è§£
                è¦è¯„ä¼°ä¸€æ¡è·¯å¾„ Sâ†’...â†’uâ†’v çš„å¥½åï¼Œåªéœ€è¦ç›¸ä¿¡åˆ°uä¸ºæ­¢å·²ç»æ‰¾åˆ°äº†æœ€ä¼˜è§£dist[u]ï¼›å†åŠ ä¸Šä»uåˆ°vè¿™æ®µæ–°å¢çš„æˆæœ¬ (weight)
                ğŸ‘‰åˆ¤æ–­è·¯å¾„çš„å¥½åéœ€è¦åˆ¤æ–­å·²çŸ¥æœ€ä½æˆæœ¬ + å¢é‡æˆæœ¬çš„å¤§å°
                dist[u] æ˜¯å·²çŸ¥æœ€ä½æˆæœ¬ï¼šåˆ°uä¸ºæ­¢å·²ç»æ‰¾åˆ°çš„æœ€ä½³æˆæœ¬è¿™æ˜¯æ²‰æ²¡æˆæœ¬ï¼›weight æ˜¯â€œå¢é‡æˆæœ¬â€ï¼šä»uåˆ°vè¿™æ®µæ–°å¢çš„æˆæœ¬
                */
                dist[v] = dist[u] + weight;// æ›´æ–°è·ç¦»// O(1)
                prev[v] = u; // è®°å½•å‰é©±èŠ‚ç‚¹
                updated = true;
            }
        }
        
        // å¦‚æœåœ¨æŸä¸€è½®ä¸­æ²¡æœ‰æ›´æ–°ï¼Œå¯ä»¥æå‰ç»“æŸ
        if (!updated) {
            console.log(`åœ¨ç¬¬ ${i + 1} è½®æå‰æ”¶æ•›`);
            break;
        }
    }
    
    // 3. æ£€æŸ¥è´Ÿæƒç¯
    let hasNegativeCycle = false;
    // è´Ÿæƒç¯æ£€æµ‹: O(E)
    for (let edge of edges) {
        const { u, v, weight } = edge;
        /*
        ğŸ‘‰åŒæ ·çš„ä»£ç ï¼Œåœ¨ V-1 è½®ä¹‹åè¿è¡Œï¼Œå°±èƒ½æ£€æµ‹å‡ºè´Ÿæƒç¯
        ä¸€ä¸ªæœ‰ V ä¸ªé¡¶ç‚¹çš„å›¾ä¸­ï¼Œä»»ä½•ä¸åŒ…å«ç¯çš„ç®€å•è·¯å¾„ï¼Œæœ€å¤šæœ‰V-1æ¡è¾¹ç»è¿‡V-1è½®åï¼šå¦‚æœå›¾ä¸­æ²¡æœ‰è´Ÿæƒç¯ï¼Œé‚£ä¹ˆdistæ•°ç»„åº”è¯¥å·²ç»ç¨³å®šäº†
        å¦‚æœå›¾ä¸­æœ‰è´Ÿæƒç¯ï¼Œé‚£ä¹ˆdistæ•°ç»„è¿˜ä¼šç»§ç»­å˜åŒ–
        ğŸ‘‰è´Ÿæƒè¾¹ vs è´Ÿæƒç¯ï¼šè´Ÿæƒè¾¹ - å•æ¡è¾¹çš„æƒé‡ä¸ºè´Ÿï¼›è´Ÿæƒç¯ - ä¸€ä¸ªç¯çš„æ€»æƒé‡ä¸ºè´Ÿ
        */
        if (dist[u] + weight < dist[v]) {
            hasNegativeCycle = true;
            console.log(`å‘ç°è´Ÿæƒç¯ï¼è¾¹: ${u} -> ${v} = ${weight}`);
            break;
        }
    }
    
    return {
        distances: dist,
        predecessors: prev,
        hasNegativeCycle // è¿”å›æ˜¯å¦æ£€æµ‹åˆ°è´Ÿæƒç¯
    };
}
// è¾…åŠ©å‡½æ•°ï¼šé‡å»ºè·¯å¾„
function reconstructPath(prev, start, end) {
    const path = [];
    let current = end;
    
    while (current !== start) {//å¾ªç¯æ¡ä»¶ï¼šå½“å‰èŠ‚ç‚¹ä¸æ˜¯èµ·ç‚¹æ—¶å°±ç»§ç»­ï¼Œæˆ‘ä»¬è¦ä»ç»ˆç‚¹ä¸€ç›´å›æº¯åˆ°èµ·ç‚¹
        path.unshift(current);//æŠŠå½“å‰èŠ‚ç‚¹åŠ å…¥åˆ°è·¯å¾„çš„å¼€å¤´ï¼Œåå‘é‡å»ºè·¯å¾„
        current = prev[current];//æ²¿ç€å‰é©±æŒ‡é’ˆå¾€å›èµ°ï¼Œprev[current] å‘Šè¯‰æˆ‘ä»¬ current èŠ‚ç‚¹æ˜¯ä»å“ªä¸ªèŠ‚ç‚¹æ¥çš„
        if (current === null && path[0] !== start) {//å®‰å…¨æ£€æŸ¥ï¼šå¦‚æœé‡åˆ° null ä½†è¿˜æ²¡å›åˆ°èµ·ç‚¹ï¼Œè¯´æ˜è·¯å¾„ä¸å®Œæ•´ï¼Œè¿™æ„å‘³ç€ç»ˆç‚¹ä¸å¯è¾¾
            return null; // ä¸å¯è¾¾
        }
    }
    
    path.unshift(start);
    return path;
/*
ğŸ‘‰æ³¢é‚£å¥‘æ•°åˆ—ï¼š
0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...
è§„åˆ™å¾ˆç®€å•ï¼šç¬¬0ä¸ªæ•°ï¼š0ï¼Œ1ä¸ªæ•°ï¼š1ï¼Œç¬¬nä¸ªæ•°ï¼šï¼ˆn-1)ä¸ªæ•° + ç¬¬(n-2)ä¸ªæ•°
F(0) = 0  F(1) = 1  
F(n) = F(n-1) + F(n-2)  (å½“ n â‰¥ 2)
æ–¹æ³•ä¸€ï¼šæš´åŠ›é€’å½’ï¼ˆæœ€ç›´è§‚çš„æ–¹æ³•ï¼‰                            æ–¹æ³•äºŒï¼šåŠ å¤‡å¿˜å½•ï¼ˆè®°å¿†åŒ–æœç´¢ï¼‰
function fibonacciNaive(n) {                          function fibonacciMemo(n, memo = {}) {
    if (n === 0) return 0;                                  if (n === 0) return 0;
    if (n === 1) return 1;                                  if (n === 1) return 1;
    return fibonacciNaive(n-1) + fibonacciNaive(n-2);                                                        
    æ—¶é—´å¤æ‚åº¦ï¼šO(2â¿) â€”â€” æŒ‡æ•°çˆ†ç‚¸                               // å¦‚æœç®—è¿‡ï¼Œç›´æ¥è¿”å›ç»“æœ
    }                                                        if (memo[n] !== undefined) {
                                                                return memo[n];
                                                            }
                                                            // æ²¡ç®—è¿‡ï¼Œè®¡ç®—å¹¶è®°ä½
                                                            memo[n] = fibonacciMemo(n-1, memo) + fibonacciMemo(n-2, memo);
                                                            return memo[n];
                                                        }
æ–¹æ³•ä¸‰ï¼šåŠ¨æ€è§„åˆ’ï¼ˆè‡ªåº•å‘ä¸Šï¼‰æ—¶é—´å¤æ‚åº¦é™ä¸º O(n)                 æ–¹æ³•å››ï¼šç©ºé—´ä¼˜åŒ–ï¼šç©ºé—´å¤æ‚åº¦ä» O(n) é™ä¸º O(1)ï¼Œä½†æ€æƒ³è¿˜æ˜¯åŠ¨æ€è§„åˆ’
function fibonacciDP(n) {                                    function fibonacciOptimal(n) {
    if (n === 0) return 0;                                            if (n === 0) return 0;
    if (n === 1) return 1;                                            if (n === 1) return 1;
                                                              let prev2 = 0;  // F(0)
    const dp = [0, 1]; // dp[0] = 0, dp[1] = 1                let prev1 = 1;  // F(1)
                                                              for (let i = 2; i <= n; i++) {
    for (let i = 2; i <= n; i++) {                                    const current = prev1 + prev2;
        dp[i] = dp[i-1] + dp[i-2];                                    prev2 = prev1;  // æ›´æ–°ä¸ºå‰ä¸€ä¸ª
    }                                                          prev1 = current; // æ›´æ–°ä¸ºå½“å‰
                                                                   }
    return dp[n];                                              return prev1;
}
ğŸ‘‰æ—¶é—´å¤æ‚åº¦ï¼š
1. åˆå§‹åŒ–ï¼šO(V)ï¼šéå† V ä¸ªé¡¶ç‚¹ï¼Œè®¾ç½®åˆå§‹è·ç¦»
2. æ ¸å¿ƒæ¾å¼›ï¼šO(V Ã— E)
    å¤–å±‚å¾ªç¯ï¼šV-1 æ¬¡ â‰ˆ O(V)
    å†…å±‚å¾ªç¯ï¼šE æ¬¡ï¼ˆéå†æ‰€æœ‰è¾¹ï¼‰
    å†…å±‚æ“ä½œï¼šO(1) çš„æ¯”è¾ƒå’Œèµ‹å€¼
    æ€»è®¡ï¼šV Ã— E Ã— O(1) = O(V Ã— E)
3. è´Ÿæƒç¯æ£€æµ‹ï¼šO(E)ï¼Œéå†æ‰€æœ‰è¾¹ä¸€æ¬¡ï¼šO(E)
æ€»æ—¶é—´å¤æ‚åº¦ï¼šO(V) + O(V Ã— E) + O(E) = O(V Ã— E)V Ã— E é€šå¸¸è¿œå¤§äº V å’Œ Eï¼Œæ‰€ä»¥ä¸»å¯¼é¡¹æ˜¯ O(V Ã— E)
*/
/*
ğŸ‘‰Bellman-Ford æ˜¯ä¸€ä¸ªåŸºäºåŠ¨æ€è§„åˆ’çš„ã€ç”¨äºå•æºæœ€çŸ­è·¯å¾„é—®é¢˜çš„å®‰å…¨å®¡è®¡ç®—æ³•ï¼Œæ ¸å¿ƒä¼˜åŠ¿æ˜¯ç”¨ç®€å•ç»Ÿä¸€çš„è§„åˆ™è§£å†³å¤æ‚é—®é¢˜
é¦–è¦ä»»åŠ¡æ˜¯ç¡®å®šç³»ç»Ÿï¼ˆå›¾ï¼‰ä¸­æ˜¯å¦å­˜åœ¨è‡´å‘½çš„é‡‘èæ¼æ´ï¼ˆä»æºç‚¹å¯è¾¾çš„è´Ÿæƒç¯ï¼‰ã€‚åªæœ‰åœ¨å®¡è®¡é€šè¿‡ï¼ˆæœªå‘ç°è´Ÿæƒç¯ï¼‰çš„æƒ…å†µä¸‹ï¼Œå®ƒæä¾›çš„è§£å†³æ–¹æ¡ˆï¼ˆæœ€çŸ­è·¯å¾„ï¼‰æ‰æ˜¯å¯ä¿¡çš„
å®ƒçš„æ ¸å¿ƒæ˜¯â€œæ£€æµ‹â€:å®ƒä¸ä»…æ˜¯ä¸ºäº†è®¡ç®—æœ‰è´Ÿæƒè¾¹æ—¶çš„æœ€çŸ­è·¯å¾„ï¼Œæ›´æ˜¯ä¸ºäº†å›ç­”ä¸€ä¸ªè‡³å…³é‡è¦çš„é—®é¢˜ï¼šè¿½æ±‚çš„è¿™æ¡æœ€ä¼˜è·¯å¾„åˆ°åº•å­˜ä¸å­˜åœ¨
å…·ä½“è¡¨ç°ä¸ºï¼š
1.è·¯å¾„çš„é•¿åº¦ç”±è¾¹çš„æ•°é‡å†³å®š:åœ¨ä¸€ä¸ªæœ‰ V ä¸ªé¡¶ç‚¹çš„å›¾ä¸­ï¼Œä»»ä½•ä¸åŒ…å«ç¯çš„ç®€å•è·¯å¾„ï¼Œå…¶è¾¹æ•°æœ€å¤šä¸º V-1:å¦‚æœä¸€æ¡è·¯å¾„çš„è¾¹æ•° â‰¥ Vï¼Œæ ¹æ®é¸½å·¢åŸç†ï¼Œå®ƒå¿…ç„¶é‡å¤ç»è¿‡äº†æŸä¸ªé¡¶ç‚¹ï¼Œå³å®ƒåŒ…å«äº†ä¸€ä¸ªç¯
â€œè¾¹çš„æ•°é‡â€ kï¼Œæˆä¸ºäº†æˆ‘ä»¬æ„å»ºè§£å†³æ–¹æ¡ˆçš„è„šæ‰‹æ¶ã€‚ æˆ‘ä»¬çŸ¥é“äº†ä»å“ªé‡Œå¼€å§‹ï¼ˆk=0ï¼‰ï¼Œä¹ŸçŸ¥é“åˆ°å“ªé‡Œç»“æŸï¼ˆk=V-1ï¼‰ã€‚æ¯ä¸€ä¸ªé˜¶æ®µ k çš„è§£ï¼Œéƒ½ç¨³å›ºåœ°æ„å»ºåœ¨å‰ä¸€ä¸ªé˜¶æ®µ k-1 çš„åŸºç¡€ä¹‹ä¸Š
è¿™ä¸ªç¯çš„å­˜åœ¨ï¼Œéä½†æ²¡æœ‰å¢åŠ è·¯å¾„çš„æˆæœ¬ï¼Œåè€Œé™ä½äº†æ€»æˆæœ¬;ç»“è®ºï¼šè¿™ä¸ªç¯çš„æ€»æƒé‡æ˜¯è´Ÿçš„
2.dp[k][v]:åœ¨è¿›è¡Œäº†Kä¸ªé˜¶æ®µçš„æ¢ç´¢åæ‰€èƒ½æ‰¾åˆ°çš„åˆ°è¾¾vç‚¹çš„æœ€å¥½æ–¹æ¡ˆ:æ€»å…±v-1ä¸ªé˜¶æ®µã€‚
3.â€œåŠ¨æ€è§„åˆ’â€æ€æƒ³ï¼šä¸€ä¸ªå¤æ‚é—®é¢˜çš„æœ€ä¼˜è§£ï¼Œå¯ä»¥ç”±å…¶å­é—®é¢˜çš„æœ€ä¼˜è§£æ„é€ å‡ºæ¥

ğŸ‘‰â€œå›¾â€å»ºæ¨¡çš„å¾€å¾€æ˜¯æŠ½è±¡å…³ç³»ï¼›åœ¨è¿™äº›å…³ç³»ä¸­ï¼Œâ€œè´Ÿæƒâ€éå¸¸æ™®éâ€œè·¯å¾„â€æˆæœ¬ä¼šæ˜¯è´Ÿçš„åœºæ™¯:
é‡‘èä¸å¥—åˆ©ï¼šä¸ç¡®å®šæ€§å’Œé£é™©è¿™å¯ä»¥æŠ½è±¡ä¸ºè´Ÿæƒé‡ï¼Œæ¯”å¦‚å¦‚æœèµ°è¿™æ¡é™©è·¯ï¼Œè™½ç„¶è·ç¦»è¿œä½†è¢«å‘ç°æ¦‚ç‡ä½ï¼Œç›¸å½“äºæ”¶ç›Š
    é—®é¢˜ï¼š å°†è´§å¸Aè½¬æ¢æˆBï¼Œå†è½¬æ¢æˆCï¼Œæœ€åæ¢å›Aï¼Œä½ æ‰‹é‡Œçš„é’±åè€Œå˜å¤š
    å»ºæ¨¡ï¼š é¡¶ç‚¹æ˜¯è´§å¸ï¼Œè¾¹æ˜¯å…‘æ¢æ±‡ç‡ã€‚å¦‚æœ æ±‡ç‡ < 1ï¼Œå– -log(æ±‡ç‡) ä½œä¸ºæƒé‡ï¼Œé‚£ä¹ˆä¸€ä¸ªèƒ½èµšé’±çš„å¾ªç¯å…‘æ¢è·¯å¾„ï¼Œå…¶æ€»æƒé‡å°±æ˜¯è´Ÿçš„ï¼Bellman-Ford èƒ½ç›´æ¥æ£€æµ‹å‡ºè¿™ç§â€œèµšé’±å¾ªç¯â€ï¼ˆå³è´Ÿæƒç¯ï¼‰ã€‚


ğŸ‘‰ç®€æ´æ€§çš„å¯ç¤ºï¼š
å¥½çš„ç®—æ³•æºäºæ·±åˆ»çš„æ´å¯Ÿï¼Œè€Œä¸æ˜¯å¤æ‚çš„æŠ€å·§ï¼›ä¸é—®æ€ä¹ˆæ‰¾æœ€çŸ­è·¯å¾„è€Œæ˜¯é—®æœ€çŸ­è·¯å¾„åº”è¯¥æ»¡è¶³ä»€ä¹ˆæ€§è´¨
æœ‰æ—¶å€™æœ€é€šç”¨æ³•ï¼ˆæ£€æŸ¥æ‰€æœ‰è¾¹ V-1 æ¬¡ï¼‰åè€Œæ˜¯æœ€ç¨³å¥çš„
æ•°å­¦çš„ä¼˜é›…å¾€å¾€ä½“ç°åœ¨ï¼šç”¨ç®€å•è§„åˆ™æè¿°å¤æ‚ç°è±¡
å·¥ç¨‹æ™ºæ…§ï¼šç¨³å¥ä¼˜äºå–å·§

ğŸ‘‰åŠ¨æ€è§„åˆ’-åˆ©ç”¨å·²çŸ¥ä¿¡æ¯ç›´è¾¾ç›®æ ‡
åŠ¨æ€è§„åˆ’ï¼šæ£€æŸ¥ä¹‹å‰æ˜¯å¦ç»å†è¿‡ç±»ä¼¼é—®é¢˜ï¼Œç¬¬ä¸€æ¬¡é‡åˆ°ï¼Œè®¤çœŸå¤„ç†å¹¶è®°å½•æ•™è®­ï¼›ç¬¬äºŒæ¬¡é‡åˆ°æ—¶è¿”å›å­˜å‚¨çš„è§£å†³æ–¹æ¡ˆï¼Œæ£€æŸ¥å‚è€ƒå†å²è¿çº¦è®°å½•ã€‚
è®°å½•ç»éªŒï¼šä¸è¦é‡å¤è®¡ç®—å·²ç»çŸ¥é“çš„ç»“æœ
ç³»ç»Ÿå­¦ä¹ ï¼šä»åŸºç¡€æƒ…å†µå¼€å§‹ï¼Œé€æ­¥æ„å»ºå¤æ‚é—®é¢˜çš„è§£å†³æ–¹æ¡ˆ
æ£€æµ‹å¾ªç¯ï¼šè¯†åˆ«é‚£äº›è®©ä½ é™·å…¥æ— é™ç—›è‹¦çš„æ¨¡å¼
æå‰ç»ˆæ­¢ï¼šå‘ç°æƒ…å†µä¸ä¼šæ”¹å–„æ—¶ï¼ŒåŠæ—¶æ­¢æŸï¼Œé¿å…é‡å¤ç—›è‹¦
*/
}
//æµ‹è¯•
const testGraph = {
    vertices: ['S', 'A', 'B', 'C'],
    edges: [
        { u: 'S', v: 'A', weight: 4 },
        { u: 'S', v: 'B', weight: 5 },
        { u: 'A', v: 'B', weight: -2 },
        { u: 'A', v: 'C', weight: 1 },
        { u: 'B', v: 'C', weight: 3 }
    ]
};
// è¿è¡Œç®—æ³•
const result = bellmanFord(testGraph, 'S');
console.log('æœ€çŸ­è·ç¦»:', result.distances);
console.log('å‰é©±èŠ‚ç‚¹:', result.predecessors);
console.log('å­˜åœ¨è´Ÿæƒç¯:', result.hasNegativeCycle);
// æµ‹è¯•è·¯å¾„é‡å»º
const pathToC = reconstructPath(result.predecessors, 'S', 'C');
console.log('åˆ° C çš„è·¯å¾„:', pathToC);
//çœŸæ­£çš„è´Ÿæƒç¯ï¼ˆç®—æ³•åº”è¯¥æ£€æµ‹åˆ°ï¼‰
const negativeCycleGraph = {
    vertices: ['S', 'A', 'B', 'C'],
    edges: [
        { u: 'S', v: 'A', weight: 1 },
        { u: 'A', v: 'B', weight: 1 },
        { u: 'B', v: 'C', weight: 1 },
        { u: 'C', v: 'A', weight: -4 }, // å½¢æˆè´Ÿæƒç¯ A->B->C->A
        { u: 'C', v: 'D', weight: 1 },
        { u: 'D', v: 'E', weight: 1 }
    ]
};
//å¤šä¸ªè´Ÿæƒè¾¹ï¼Œä½†æ²¡æœ‰è´Ÿæƒç¯
const multipleNegativeEdges = {
    vertices: ['S', 'A', 'B', 'C', 'D'],
    edges: [
        { u: 'S', v: 'A', weight: 2 },
        { u: 'A', v: 'B', weight: -5 }, // å¤§å¹…æŠ˜æ‰£
        { u: 'B', v: 'C', weight: -3 }, // åˆæ‰“æŠ˜
        { u: 'C', v: 'D', weight: 1 },
        { u: 'S', v: 'D', weight: 10 }  // ç›´é£å¾ˆè´µ
    ]
};
//éšè—åœ¨æ·±å¤„çš„è´Ÿæƒç¯
const hiddenNegativeCycle = {
    vertices: ['S', 'A', 'B', 'C', 'D', 'E'],
    edges: [
        { u: 'S', v: 'A', weight: 3 },
        { u: 'A', v: 'B', weight: 2 },
        { u: 'B', v: 'C', weight: 1 },
        { u: 'C', v: 'B', weight: -4 }, // éšè—çš„è´Ÿæƒç¯ B->C->B
        { u: 'C', v: 'D', weight: 5 },
        { u: 'D', v: 'E', weight: 2 }
    ]
};
//è´Ÿæƒè¾¹è®©ä¸å¯è¾¾å˜å¯è¾¾
const negativeMakesReachable = {
    vertices: ['S', 'A', 'B', 'C'],
    edges: [
        { u: 'S', v: 'A', weight: 5 },
        { u: 'A', v: 'B', weight: -10 }, // å·¨é¢è¡¥è´´
        { u: 'B', v: 'C', weight: 8 },
        // æ³¨æ„ï¼šæ²¡æœ‰ S->C çš„ç›´é£è·¯å¾„
    ]
};
console.log("=== æµ‹è¯•1: çœŸæ­£çš„è´Ÿæƒç¯ ===");
const result1 = bellmanFord(negativeCycleGraph, 'S');
console.log('å­˜åœ¨è´Ÿæƒç¯:', result1.hasNegativeCycle);

console.log("\n=== æµ‹è¯•2: å¤šä¸ªè´Ÿæƒè¾¹ ===");
const result2 = bellmanFord(multipleNegativeEdges, 'S');
console.log('æœ€çŸ­è·ç¦»:', result2.distances);
console.log('åˆ°Dçš„è·¯å¾„:', reconstructPath(result2.predecessors, 'S', 'D'));

console.log("\n=== æµ‹è¯•3: éšè—çš„è´Ÿæƒç¯ ===");
const result3 = bellmanFord(hiddenNegativeCycle, 'S');
console.log('å­˜åœ¨è´Ÿæƒç¯:', result3.hasNegativeCycle);

console.log("\n=== æµ‹è¯•4: è´Ÿæƒè¾¹åˆ›é€ å¯è¾¾æ€§ ===");
const result4 = bellmanFord(negativeMakesReachable, 'S');
console.log('åˆ°Cçš„è·ç¦»:', result4.distances['C']);
console.log('åˆ°Cçš„è·¯å¾„:', reconstructPath(result4.predecessors, 'S', 'C'));


/*ç¡¬å¸é—®é¢˜ï¼šç¡¬å¸é¢é¢ï¼š[1, 2, 5] å…ƒï¼›ç›®æ ‡é‡‘é¢ï¼š11 å…ƒï¼›é—®é¢˜ï¼š ç”¨æœ€å°‘çš„ç¡¬å¸å‡‘å‡º 11 å…ƒ
æ­¥éª¤1ï¼šå®šä¹‰çŠ¶æ€ï¼›dp[i] = å‡‘å‡ºé‡‘é¢ i éœ€è¦çš„**æœ€å°‘ç¡¬å¸æ•°**
æ­¥éª¤2ï¼šåŸºç¡€æƒ…å†µï¼›dp[0] = 0   // å‡‘å‡º0å…ƒéœ€è¦0æšç¡¬å¸
æ­¥éª¤3ï¼šçŠ¶æ€è½¬ç§»ï¼›å¯¹äºæ¯ä¸ªé‡‘é¢ iï¼Œæˆ‘ä»¬è€ƒè™‘æœ€åä¸€æ­¥ç”¨äº†å“ªä¸ªç¡¬å¸
// ä¼ªä»£ç //è¦å‡‘å‡º i å…ƒå…ˆçœ‹çœ‹å‡‘å‡º (i-1) å…ƒã€(i-2) å…ƒã€(i-5) å…ƒå„éœ€è¦å¤šå°‘ç¡¬å¸ï¼Œç„¶ååŠ ä¸Šæœ€åé‚£æšç¡¬å¸
dp[i] = min(dp[i] = å‡‘å‡ºé‡‘é¢ i å…ƒæ‰€éœ€è¦çš„ã€æœ€å°‘ç¡¬å¸æ•°é‡ã€‘
    dp[i - 1] + 1,   // æœ€åç”¨äº†1å…ƒç¡¬å¸
    dp[i - 2] + 1,   // æœ€åç”¨äº†2å…ƒç¡¬å¸  
    dp[i - 5] + 1    // æœ€åç”¨äº†5å…ƒç¡¬å¸
)
*/
function coinChange(coins, amount) {//coins - æ‹¥æœ‰çš„ç¡¬å¸ç§ç±»ï¼Œamount - éœ€è¦å…‘æ¢æˆä¸ºé›¶é’±çš„æ€»é‡‘é¢
    // dp[i] è¡¨ç¤ºå‡‘å‡ºé‡‘é¢ i éœ€è¦çš„æœ€å°‘ç¡¬å¸æ•°
    const dp = new Array(amount + 1).fill(Infinity);//Infinity çš„å«ä¹‰ï¼š "è¿™ä¸ªé‡‘é¢ç›®å‰è¿˜ä¸çŸ¥é“æ€ä¹ˆå‡‘å‡ºæ¥"
    dp[0] = 0;  // åŸºç¡€æƒ…å†µ
    
    //åŠ¨æ€è§„åˆ’çš„å¼•æ“// æ„å»º dp æ•°ç»„
    for (let i = 1; i <= amount; i++) {//å¤–å±‚å¾ªç¯ï¼šä»1æ¥¼å»ºåˆ°amountæ¥¼ï¼šè¦å»ºç¬¬iå±‚ï¼Œå¿…é¡»å…ˆå»ºå¥½ç¬¬(i-1)ã€(i-2)ã€(i-5)å±‚
        for (let coin of coins) {//å†…å±‚å¾ªç¯ï¼šæšä¸¾æ‰€æœ‰å¯èƒ½çš„è§£å†³æ–¹æ¡ˆï¼›å¯¹äºæ­£åœ¨å»ºçš„ç¬¬iå±‚ï¼Œæˆ‘ä»¬æ£€æŸ¥æ¯ç§ç¡¬å¸ï¼šæ‰¾å‡ºå»ºåˆ°ç¬¬iå±‚çš„æ‰€æœ‰å¯èƒ½é€”å¾„
            if (i - coin >= 0) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
/*æ¯”è¾ƒä¸¤ä¸ªå€™é€‰æ–¹æ¡ˆï¼šå€™é€‰æ–¹æ¡ˆAï¼šdp[i]è¿™æ˜¯å½“å‰å·²çŸ¥çš„å‡‘å‡º i å…ƒçš„æœ€ä½³æ–¹æ¡ˆï¼Œå¯èƒ½æ˜¯ä¹‹å‰å…¶ä»–ç¡¬å¸æ‰¾åˆ°çš„æ›´å¥½æ–¹æ¡ˆï¼Œä¹Ÿå¯èƒ½æ˜¯åˆå§‹çš„ Infinityï¼ˆè¡¨ç¤ºè¿˜æ²¡æ‰¾åˆ°æ–¹æ¡ˆï¼‰
å€™é€‰æ–¹æ¡ˆBï¼šdp[i - coin] + 1è¿™æ˜¯æ–°å‘ç°çš„æ–¹æ¡ˆï¼šå…ˆç”¨æœ€ä¼˜æ–¹å¼å‡‘å‡º (i-coin) å…ƒï¼Œå†åŠ ä¸Šè¿™æš coin ç¡¬å¸
dp[i]çš„ç»“æœä¼šéšç€coinçš„é¢é¢çš„å˜åŒ–è€Œå˜åŒ–äº§ç”Ÿä¸åŒçš„æ–¹æ¡ˆå’Œç»“æœ
*/
}
        }
    }
    return dp[amount] === Infinity ? -1 : dp[amount];
}

// æµ‹è¯•
console.log(coinChange([1, 2, 5], 11));  // è¾“å‡º: 3 (5+5+1)
console.log(coinChange([2], 3));         // è¾“å‡º: -1 (æ— æ³•å‡‘å‡º)

//=================================ğŸ”„Floyd-Warshall=============================//
/*
ğŸ‘‰Floyd-Warshallç®—æ³•
éå†æ‰€æœ‰iå’Œjï¼šå¯¹äºæ¯ä¸ªä¸­è½¬ç«™kï¼Œæˆ‘ä»¬éƒ½è¦æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„èµ·ç‚¹iå’Œç»ˆç‚¹jçš„ç»„åˆ
æ¯ä¸€è½® k éƒ½åœ¨åšä¸¤ä»¶äº‹ï¼šåˆ©ç”¨å‰é¢è½®æ¬¡çš„ç»“æœï¼Œå‘ç°æ–°è·¯å¾„ï¼šä½¿ç”¨å½“å‰çš„ä¸­è½¬ç«™kä½¿ç”¨æ›´å¥½çš„åŸºç¡€ï¼šåŸºäºå‰é¢æ‰€æœ‰è½®æ¬¡ä¼˜åŒ–è¿‡çš„è·ç¦»å€¼
// ç¬¬kè½®çš„è®¡ç®—ï¼š
dist[i][j] = min(//iå’Œjçš„éå†ç¡®ä¿æˆ‘ä»¬æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„èµ·ç‚¹å’Œç»ˆç‚¹ç»„åˆï¼›i=èµ·ç‚¹ï¼ˆä»å“ªå„¿å‡ºå‘ï¼‰j = ç»ˆç‚¹ï¼ˆåˆ°å“ªå„¿å»ï¼‰dist[i][j] = ä»iåˆ°jçš„æœ€çŸ­è·ç¦»
    dist[i][j],           // å‰k-1è½®æ‰¾åˆ°çš„æœ€ä½³å€¼
    dist[i][k] + dist[k][j]  // ä½¿ç”¨kä¸­è½¬çš„æ–°æ–¹æ¡ˆ
)
ğŸ‘‰æ¯”è¾ƒ
ç®—æ³•	         k çš„å«ä¹‰	               "é˜¶æ®µ"çš„æ€§è´¨                                       ç›¸åŒç‚¹                       
Bellman-Ford	å…è®¸çš„è¾¹æ•°	              è·¯å¾„é•¿åº¦çš„æ‰©å±•                                  åŸºäºå·²çŸ¥çš„å±€éƒ¨æœ€ä¼˜è§£ï¼Œæ„å»ºå…¨å±€æœ€ä¼˜è§£
Floyd-Warshall	å…è®¸çš„ä¸­è½¬ç«™	          å·¥å…·é›†çš„æ‰©å±•/æ¯ä¸€è½® k éƒ½åœ¨æ‰©å±•æˆ‘ä»¬å…è®¸ä½¿ç”¨çš„å·¥å…·é›†

ğŸ‘‰Floyd-Warshall ç®—æ³•çš„ç¾å¦™ä¹‹å¤„ï¼š
    ç®€æ´æ€§ï¼šä¸‰é‡å¾ªç¯ + ä¸€ä¸ªæ¡ä»¶åˆ¤æ–­è§£å†³äº†å…¨æºæœ€çŸ­è·¯å¾„é—®é¢˜
    é€šç”¨æ€§å¼ºï¼šèƒ½å¤„ç†è´Ÿæƒè¾¹ï¼ˆä½†ä¸èƒ½æœ‰è´Ÿæƒç¯ï¼‰
    å®Œæ•´æ€§ï¼šä¸‰é‡å¾ªç¯ç¡®ä¿è€ƒè™‘æ‰€æœ‰å¯èƒ½æ€§
    æ­£ç¡®æ€§ï¼šæ•°å­¦ä¸Šè¯æ˜ç»è¿‡Vè½®åæ‰¾åˆ°æ‰€æœ‰æœ€çŸ­è·¯å¾„
æ—¶é—´å¤æ‚åº¦ï¼š O(VÂ³) - ä¸‰é‡å¾ªç¯
ç©ºé—´å¤æ‚åº¦ï¼š O(VÂ²) - éœ€è¦å­˜å‚¨è·ç¦»çŸ©é˜µ
*/
function floydWarshall(graph) {
    const { vertices, edges } = graph;
    const V = vertices.length;
    
    // 1. åˆå§‹åŒ–è·ç¦»çŸ©é˜µ
    const dist = Array(V).fill().map(() => Array(V).fill(Infinity));
    //åˆ›å»º VÃ—V çš„çŸ©é˜µï¼Œæ‰€æœ‰å€¼åˆå§‹ä¸º Infinityè¡¨ç¤ºä¸€å¼€å§‹æˆ‘ä»¬è®¤ä¸ºæ‰€æœ‰ç‚¹ä¹‹é—´éƒ½ä¸å¯è¾¾
    // 2. è‡ªå·±åˆ°è‡ªå·±çš„è·ç¦»ä¸º0ï¼Œå¯¹è§’çº¿ä¸º0
    for (let i = 0; i < V; i++) {
        dist[i][i] = 0;
    }
    // 3. è®¾ç½®ç›´æ¥è¾¹çš„è·ç¦»
    for (let edge of edges) {
        const { u, v, weight } = edge;
        dist[u][v] = weight;//å¡«å……å·²çŸ¥çš„ç›´æ¥è¿æ¥
        console.log("åˆå§‹è·ç¦»çŸ©é˜µ:");
        printMatrix(dist);
    }
    // 4. æ ¸å¿ƒç®—æ³•ï¼šä¸‰é‡å¾ªç¯
    for (let k = 0; k < V; k++) {
        console.log(`\n=== ç¬¬ ${k} è½®ï¼šè€ƒè™‘èŠ‚ç‚¹ ${k} ä½œä¸ºä¸­è½¬ç«™ ===`);
        let updates = 0;
        for (let i = 0; i < V; i++) {
            for (let j = 0; j < V; j++) {
                // ä¿®å¤ï¼šåœ¨ifè¯­å¥å†…éƒ¨å®šä¹‰oldValue
                if (dist[i][k] + dist[k][j] < dist[i][j]) {//å¦‚æœé€šè¿‡kä¸­è½¬æ¯”å½“å‰è·¯å¾„æ›´çŸ­ï¼Œæ›´æ–°ï¼šå°±ç”¨æ›´çŸ­çš„è·¯å¾„æ›¿æ¢å½“å‰å€¼
                    const oldValue = dist[i][j];  // åœ¨è¿™é‡Œå®šä¹‰ï¼
                    dist[i][j] = dist[i][k] + dist[k][j];
                    updates++;
                    console.log(`  æ›´æ–°: dist[${i}][${j}] = ${oldValue} -> ${dist[i][j]} (é€šè¿‡ ${i}->${k}->${j})`);
                }
            }
        }
    if (updates === 0) {//ğŸ‘‰è¿™ä¸ªifè¯­å¥åº”è¯¥åœ¨kå¾ªç¯å†…éƒ¨ï¼
            console.log("  æœ¬è½®æ— æ›´æ–°");
        }
        
        printMatrix(dist);
    }
    
    return dist;
    }
// è¾…åŠ©å‡½æ•°ï¼šæ‰“å°çŸ©é˜µ
function printMatrix(matrix) {
    console.log("è·ç¦»çŸ©é˜µ:");
    for (let i = 0; i < matrix.length; i++) {
        const row = matrix[i].map(val => val === Infinity ? "âˆ" : val.toString().padStart(2));
        console.log(`  [${row.join(", ")}]`);
    }
}

// æµ‹è¯•ç”¨ä¾‹1ï¼šç®€å•çš„ä¸‰è§’å½¢å›¾
const testGraph1 = {
    vertices: [0, 1, 2],
    edges: [
        { u: 0, v: 1, weight: 3 },
        { u: 0, v: 2, weight: 6 },
        { u: 1, v: 2, weight: 2 }
    ]
};
// æµ‹è¯•ç”¨ä¾‹2ï¼šæœ‰è´Ÿæƒè¾¹ï¼ˆä½†æ— è´Ÿæƒç¯ï¼‰
const testGraph2 = {
    vertices: [0, 1, 2, 3],
    edges: [
        { u: 0, v: 1, weight: 2 },
        { u: 1, v: 2, weight: -1 },
        { u: 2, v: 3, weight: 3 },
        { u: 3, v: 0, weight: 4 }
    ]
};
// æµ‹è¯•ç”¨ä¾‹3ï¼šæ— æ³•åˆ°è¾¾çš„æƒ…å†µ
const testGraph3 = {
    vertices: [0, 1, 2],
    edges: [
        { u: 0, v: 1, weight: 5 }
        // æ²¡æœ‰ä»1åˆ°2çš„è¾¹ï¼Œä¹Ÿæ²¡æœ‰ä»0åˆ°2çš„è¾¹
    ]
};
// è¿è¡Œæµ‹è¯•
console.log(" æµ‹è¯•1: ç®€å•ä¸‰è§’å½¢å›¾");
console.log("å›¾ç»“æ„: 0->1=3, 0->2=6, 1->2=2");
const result01 = floydWarshall(testGraph1);
console.log("\n" + "=".repeat(50) + "\n");
console.log(" æµ‹è¯•2: å¸¦è´Ÿæƒè¾¹çš„å›¾");
console.log("å›¾ç»“æ„: 0->1=2, 1->2=-1, 2->3=3, 3->0=4");
const result02 = floydWarshall(testGraph2);
console.log("\n" + "=".repeat(50) + "\n");
console.log(" æµ‹è¯•3: æœ‰ä¸å¯è¾¾èŠ‚ç‚¹çš„å›¾");
console.log("å›¾ç»“æ„: 0->1=5 (å…¶ä»–èŠ‚ç‚¹ä¸å¯è¾¾)");
const result03 = floydWarshall(testGraph3);
// éªŒè¯ç»“æœå‡½æ•°
function verifyResult(dist, expected) {
    console.log("\nâœ… éªŒè¯ç»“æœ:");
    for (let i = 0; i < dist.length; i++) {
        for (let j = 0; j < dist[i].length; j++) {
            const actual = dist[i][j];
            const expectedVal = expected[i][j];
            const status = actual === expectedVal ? "âœ“" : "âœ—";
            console.log(`  dist[${i}][${j}] = ${actual} ${status}`);
        }
    }
}
// éªŒè¯æµ‹è¯•1çš„ç»“æœ
console.log("\nğŸ“‹ æµ‹è¯•1æœŸæœ›ç»“æœ:");
console.log("  0->0=0, 0->1=3, 0->2=5");
console.log("  1->0=âˆ, 1->1=0, 1->2=2"); 
console.log("  2->0=âˆ, 2->1=âˆ, 2->2=0");
verifyResult(result01, [
    [0, 3, 5],
    [Infinity, 0, 2],
    [Infinity, Infinity, 0]
]);

//æµ‹è¯•4ï¼šå¯†é›†ç½‘ç»œ
const denseGraph = {
    vertices: [0, 1, 2, 3],
    edges: [
        { u: 0, v: 1, weight: 2 }, { u: 0, v: 2, weight: 4 }, { u: 0, v: 3, weight: 8 },
        { u: 1, v: 0, weight: 2 }, { u: 1, v: 2, weight: 1 }, { u: 1, v: 3, weight: 6 },
        { u: 2, v: 0, weight: 4 }, { u: 2, v: 1, weight: 1 }, { u: 2, v: 3, weight: 3 },
        { u: 3, v: 0, weight: 8 }, { u: 3, v: 1, weight: 6 }, { u: 3, v: 2, weight: 3 }
    ]
};
// æŒ‘æˆ˜ï¼šæ‰¾å‡ºæ‰€æœ‰è¿‚å›è·¯å¾„æ¯”ç›´é£æ›´çŸ­çš„ä¾‹å­
//æµ‹è¯•5ï¼šæç«¯è´Ÿæƒè¾¹
const extremeNegativeGraph = {
    vertices: [0, 1, 2, 3],
    edges: [
        { u: 0, v: 1, weight: 10 },
        { u: 1, v: 2, weight: -20 },  // å¤§å¹…è´Ÿæƒ
        { u: 2, v: 3, weight: 5 },
        { u: 3, v: 1, weight: -15 }   // å½¢æˆå¼ºè´Ÿæƒå½±å“
    ]
};
// æŒ‘æˆ˜ï¼šå¤„ç†å¼ºçƒˆçš„è´Ÿæƒè¾¹æ•ˆåº”
//æµ‹è¯•6ï¼šå®Œå…¨å›¾
const completeGraph = {
    vertices: [0, 1, 2],
    edges: [
        { u: 0, v: 1, weight: 1 }, { u: 0, v: 2, weight: 1 },
        { u: 1, v: 0, weight: 1 }, { u: 1, v: 2, weight: 1 },
        { u: 2, v: 0, weight: 1 }, { u: 2, v: 1, weight: 1 }
    ]
};
// æŒ‘æˆ˜ï¼šæ‰€æœ‰èŠ‚ç‚¹éƒ½äº’ç›¸è¿æ¥
console.log("ğŸ§ª æµ‹è¯•4: å¯†é›†ç½‘ç»œ");
const result04 = floydWarshall(denseGraph);
console.log("å¯†é›†ç½‘ç»œç»“æœ:", result04);

console.log("\nğŸ§ª æµ‹è¯•5: æç«¯è´Ÿæƒè¾¹");
const result05 = floydWarshall(extremeNegativeGraph);
console.log("æç«¯è´Ÿæƒç»“æœ:", result05);

console.log("\nğŸ§ª æµ‹è¯•6: å®Œå…¨å›¾");
const result06 = floydWarshall(completeGraph);
console.log("å®Œå…¨å›¾ç»“æœ:", result06);

// æ›´å¥½çš„æ‰“å°å‡½æ•°
function printDistanceMatrix(matrix) {
    console.log("æœ€çŸ­è·ç¦»çŸ©é˜µ:");
    console.log("ä»\\åˆ° " + matrix[0].map((_, j) => ` ${j}  `).join(""));
    matrix.forEach((row, i) => {
        const rowStr = row.map(val => val === Infinity ? " âˆ " : val.toString().padStart(2)).join("  ");
        console.log(`  ${i}    ${rowStr}`);
    });
}
const testOptimal = {
    vertices: [0, 1, 2, 3],
    edges: [
        { u: 0, v: 1, weight: 5 },   // ç›´é£å¾ˆè´µ
        { u: 0, v: 2, weight: 2 },   // ä¸­è½¬ç«™
        { u: 2, v: 1, weight: 1 },   // ä¾¿å®œè·¯å¾„ï¼
        { u: 1, v: 3, weight: 4 },
        { u: 2, v: 3, weight: 6 }
    ]
};
// é¢„æœŸæœ€ä¼˜è·¯å¾„ï¼š
// 0â†’1: 0â†’2â†’1 = 2+1 = 3 (æ¯”ç›´é£5æ›´ä¼˜ï¼)
// 0â†’3: 0â†’2â†’1â†’3 = 2+1+4 = 7 (æ¯”0â†’2â†’3=8æ›´ä¼˜)
const testNegativeOptimal = {
    vertices: [0, 1, 2],
    edges: [
        { u: 0, v: 1, weight: 10 },   // ç›´é£å¾ˆè´µ
        { u: 1, v: 2, weight: -8 },   // è´Ÿæƒè¾¹ï¼Œå¤§å¹…ä¼˜æƒ ï¼
        { u: 0, v: 2, weight: 5 }     // ç›´é£ä¸­ç­‰
    ]
};
// é¢„æœŸï¼š0â†’2 åº”è¯¥é€‰æ‹© 0â†’1â†’2 = 10 + (-8) = 2 (æ¯”ç›´é£5æ›´ä¼˜ï¼)
function testOptimalPathFinding() {
    console.log("ğŸ§ª æµ‹è¯•æœ€ä¼˜è·¯å¾„æŸ¥æ‰¾èƒ½åŠ›");
    console.log("=".repeat(50));
    
    // æµ‹è¯•A
    console.log("\nğŸ“ˆ æµ‹è¯•A: ç®€å•æœ€ä¼˜è·¯å¾„");
    const resultA = floydWarshall(testOptimal);
    printDistanceMatrix(resultA);
    
    // éªŒè¯å…³é”®è·¯å¾„
    console.log("\nğŸ” éªŒè¯æœ€ä¼˜è·¯å¾„:");
    console.log(`  0â†’1: ${resultA[0][1]} (æœŸæœ›: 3) ${resultA[0][1] === 3 ? "âœ…" : "âŒ"}`);
    console.log(`  0â†’3: ${resultA[0][3]} (æœŸæœ›: 7) ${resultA[0][3] === 7 ? "âœ…" : "âŒ"}`);
    console.log(`  ç›´é£ 0â†’1 = 5, ä½†ç®—æ³•å‘ç°: 0â†’2â†’1 = 3 âœ“`);
    
    // æµ‹è¯•B  
    console.log("\nğŸ“‰ æµ‹è¯•B: è´Ÿæƒè¾¹ä¼˜åŒ–");
    const resultB = floydWarshall(testNegativeOptimal);
    printDistanceMatrix(resultB);
    
    console.log("\nğŸ” éªŒè¯è´Ÿæƒè¾¹ä¼˜åŒ–:");
    console.log(`  0â†’2: ${resultB[0][2]} (æœŸæœ›: 2) ${resultB[0][2] === 2 ? "âœ…" : "âŒ"}`);
    console.log(`  ç›´é£ 0â†’2 = 5, ä½†ç®—æ³•å‘ç°: 0â†’1â†’2 = 2 âœ“`);
    
    // æµ‹è¯•å®Œå…¨å›¾ï¼ˆä¿®å¤ç‰ˆï¼‰
    console.log("\nğŸ”„ æµ‹è¯•å®Œå…¨å›¾ï¼ˆæ­£ç¡®ç‰ˆæœ¬ï¼‰");
    const correctCompleteGraph = {
        vertices: [0, 1, 2],
        edges: [
            { u: 0, v: 1, weight: 1 }, { u: 0, v: 2, weight: 1 },
            { u: 1, v: 0, weight: 1 }, { u: 1, v: 2, weight: 1 },
            { u: 2, v: 0, weight: 1 }, { u: 2, v: 1, weight: 1 }
        ]
    };
    const resultComplete = floydWarshall(correctCompleteGraph);
    printDistanceMatrix(resultComplete);
    
    console.log("\nğŸ” éªŒè¯å®Œå…¨å›¾:");
    const allOnes = resultComplete[0][1] === 1 && resultComplete[0][2] === 1 && 
                   resultComplete[1][2] === 1;
    console.log(`  æ‰€æœ‰èŠ‚ç‚¹é—´è·ç¦»ä¸º1: ${allOnes ? "âœ…" : "âŒ"}`);
}

// è¿è¡Œæµ‹è¯•
testOptimalPathFinding();
```
