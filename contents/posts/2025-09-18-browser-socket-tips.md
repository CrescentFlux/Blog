# 理解浏览器
- **本质是客户端，浏览器进程通过网络协议，去和远方的服务器进程通信**
-  **主要任务**
```
1. 根据本地提供的URL地址，去访问各个国家的服务器(Website Server);
- DNS查询()HTTP和HTTPS的访问区别：
HTTP:去全球记录中心dns查询需要的域名对于的IP地址
HTTPS:加密的查询需要的ip地址

2. 与服务器协商，拿到想要的资源(网页，图片，视频);
- 拿到HTML,CSS,JS之后，并把它们在本地渲染成为完整可交互的网页

3. 管理记住协商细节(cookie),以便下次访问更高效；
- cookie:服务器让浏览器记在备忘录的信息，包括一些常用设置，记录凭证等等，再次访问时会向服务器出示这些备忘信息直接保持登陆状态
- 拦截跨站cookie和全方位cookie保护：是为了防止广告商等用cookie跨网站跟踪

4. 展示：把拿回的资源包括代码，文字，图片在本地电脑上重建成你能看懂的网页
```
# 进程-网络-socket
## **进程和网络通讯**
- **一个进程就是一个正在运行的程序，进程之间互相独立隔离**
- **网络是让不同及其上的进程能够通信的基础设施，互联网是全球的通行网络**
- **网络通信的核心是协议，比如TCP/IP 协议，双方握手之后才开始正式传输数据，HTTP.HTTPS是建立在TCP/IP基础协议上的高级商务用语**

## **Socket(套接字)**

### **1. 基本概念**
- socket是连接进程和网络的桥梁,它是进程用来进行网络通信的一个接口
- 一个socket由IP地址(主机地址)+端口号(分机号)唯一确定

### **2. 连接逻辑**
#### **连接过程**
```
1. 为进程申请一个接口(socket()函数)；
2. 连接到网络上的另一个进程(connect()函数)；
3. 读取发送或者写入数据等等(read()/recv();write();send()函数);
4. 中断连接(close()函数)
```
```
- 服务器进程
1.socket.bind():申请接口并告诉系统，分机号是8080；
2.socket.lisen():开始监听；
3.connection,address = socket.accept()：等待接受；
4.connection.recv():开始通信；
5.connection.send():开始交流并且回复客户端；
6.connection.close():挂断电话；
- 客户端进程
1.socket.socket():申请接口
2.socket.connect():拨号并且回复服务器收到地址和分机号
3.socket.send():回复请求
4.socket.recv():听对方的回复
5.socket.close():挂断电话
```
### **3. 通信方式**
#### **3.1 本地socket单向通信**
**核心逻辑**：
```
1.服务器端：先创建socket----绑定路径----监听连接----接受和发送数据；
2.客户端：创建socket---连接服务器路径---接受和发送数据
```
**注意事项:**
- **socket路径是否被占用残留**
```
- 如果之前运行过程序，本地路径比如/tmp/my_socket可能残留了旧的socket文件。此时新程序无法绑定该路径，导致通信失败
- 需要在服务器端代码开头，先删除旧的路径，写新的路径
```
- **客户端的路径是否正确**
```
客户端connect(socket_path)必须和服务器端的bind(socket_path)使用完全相同的路径，否则无法建立连接
```
- **服务器是否真正监听**
```
服务端代码必须包含bind(socket_path将socket绑定到本地文件路径)+listen(可等待连接的队列长度)
```
- **消息收发是否双相匹配**：
```
1. socket通信需要双向互动
客户端发送消息后，必须等待服务器回复调用recv();
服务器端收到消息后，必须主动回复客户端调用send();

2. 业务场景决定服务端是否能够主动发送消息
目的是让「主动方（客户端）先发起，被动方（服务端）后回应」，从而实现双向通信。如果你的场景需要「服务端主动」，则逻辑会反过来，但本质都是「匹配业务需求」。
```

#### **3.2 本地socket双向通信**
**核心逻辑**
```
1.recv()会一直等待程序导致代码阻塞,需要为每个连接创建两个线程，一个线程专门负责发送消息，一个线程专门负责接受消息
2.代码是否阻塞在收发，socket的recv()是阻塞函数没有数据时会一直等待，如果服务器端没有发送数据，客户端的recv()会卡住；同理服务器端没收到客户端数据也不会发送；
```

**注意事项**
- 服务端和客户端启动顺序：先启动服务端，再启动客户端
- 解决路径不存在的注意事项
```
1. 查看当前路径权限 ls -ld

2. 查看当前操作权限验证方法
print("当前用户",os.getlogin())
print("当前工作目录",os.getcwd())
print("/tmp权限",oct(os.stat("/tmp").st_mode)[-3:])

3.清理旧的路径
# 清理可能存在的旧socket文件
-服务端
if os.path.exists(socket_path):
    os.remove(socket_path)
server_socket.bind(socket_path)
server_socket.listen(1)
print("服务器已经启动等待连接 ")
-客户端
if not os.path.exists(socket_path):
    print("错误，服务端未启动！")
    print("请先运行服务端程序，然后再运行客户端")
    exit()
```
- 移动文件防止以外覆盖
```
rsync -av ~/桌面/path/socket{1,2,3}/ scripts/path/
```















