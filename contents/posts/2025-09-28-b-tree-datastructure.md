# B Tree
## 基础知识
- B树是一种多叉搜索树，每个节点可以有多个子节点，主要用于数据库存储系统
- 对于m阶B树：B树的"阶数"m表示每个节点最多有m个子节点，最多有m-1个关键字
- B树的所有叶子节点都在最底层，这是保持平衡的关键
- 对比

|特性	|红黑树|	B树|
---|---|---
|设计目标	|内存操作优化	|磁盘IO优化|
|节点大小	|很小（几个指针）|	约4KB（一磁盘页）|
|适用场景	|内存数据结构	|数据库、文件系统|
|子节点数量|二叉树每个节点最多2个|多叉树每个节点可以有多个子节点|



## 注意事项
### **关键字数**
- 关键字数(k)=最大子节点数(m)-1
- 每个节点有"容量限制"
- 关键字数和区间数：k个关键字产生(k+1)个区间，需要(k+1)个子节点；子节点就像不同的区域
- 结构
```
每个关键字分隔两个子树的取值范围
节点：[key1, key2, key3]  ← 3个关键字
子节点：C0   C1   C2   C3  ← 4个子节点
key1分隔：C0 < key1 < C1
key2分隔：C1 < key2 < C2  
key3分隔：C2 < key3 < C3
m子节点数 = 关键字数k + 1
最大子节点数m = 最大关键字数k + 1
最大关键字数k = m - 1
```
- 分隔点动态构建
```
B树通过插入过程中的自动选择来动态确定这些分隔点;
初始状态：不知道哪些是关键点
插入数据：数据自然聚集在节点中
节点饱和：当节点装满时，数据分布本身告诉我们哪里是关键分隔点
分裂提升：中间关键字天然就是好的分隔点:中间关键字能最均衡地分割数据
B树不需要预先知道数据的任何信息，而是通过一种简单的分裂规则，让最优结构从数据中自然涌现出来
```
### **阶数Order**
- 阶数m = 每个节点最多允许的子节点数（设计约束）=最大字节点数
- 本质是把物理限制转换成算法参数
- 每个节点大小 = (关键字大小×关键字数)+(指针大小×子节点数)
- 节点内存布局：每个键占4字节；每个指针占8字节；
- 节点大小可以反向得出关键字的数量；假设有k个关键字，节点大小=k×4+(k+1)×8::每个节点最多容纳340个关键字（k ≤ 340）所以就是341阶b树
- 比较

|特性|	阶数m	|分支因子b|
---|---|---
|含义|	最大允许值|	实际分析值|
|用途|	设计约束|	性能分析|
|数值|	固定值|	b = ⌈m/2⌉（最坏情况）|
|保证|	节点不会超过m个子节点	|树高度不会超过log_b(N)|

### **分支因子Branching Factor**
- 分支因子b = 实际有效子节点数（分析参数）=> 用于计算树高度
- b = ⌈m/2⌉
- 注意这里是向上取整有效防止了最坏情况链表的发生确保了性能正常;即使在最坏情况下，也不会超过log_m(N)次IO
- 当数学的连续性遇到物理的离散性时，工程要做出有利于系统稳定性的选择分支因子
- m ≈ B / (K + P) {页大小：B bytes；关键字大小：K bytes指针大小：P bytes}
- 树高度:
```
磁盘页大小 → 决定最大m值 → 影响树高度
阶数m（越大越好，但受磁盘页限制）
节点容量越大，树高度越矮
数据总量N:b = 分支因子=每个节点的子节点数
要存储N个数据：b^h ≥ N → h ≥ log_b(N)
```
- 二分查找
```
-二分查找：逻辑上的二叉树，每次比较需要计算中间位置
-对于一个有序数组，二分查找的时间复杂度应该是o(logn);无序数组顺序扫描O(n)
-直接把这种树结构显式地存储起来，并优化为多叉树来适应磁盘特性：减少树高度，减少IO次数
-二分查找比较的次数 = 隐形二叉树的高度
-二分查找的决策逻辑：遍历一棵隐式的二叉树
-显式二叉树：节点之间有明确的指针连接;隐式二叉树：没有实际的节点对象，但逻辑上存在树结构
-二叉树高度 = log₂(n)；二分查找最多需要比较次数 = 树高度；所以时间复杂度 = O(log n)
```
### 其他
1. 优势
- 保持平衡：自动平衡机制：中间关键字提升后，左右子树大小基本相等
```
-所有叶子节点都在同一层；节点太满时会分裂；太小时会合并
-高效处理海量随机数据
-平衡性保证最坏情况下的IO次数可控
```
- 保持有序：左子树 < 中间关键字 < 右子树
- 效率最优：每次分裂都能最大程度利用节点空间
- 控制节点大小(节点不会越来越大)
- 磁盘IO优化（B树的核心目标是减少磁盘IO）
```
-磁盘IO：从硬盘读取数据到内存的操作
-节点大小≈磁盘页：一次IO读取整个节点;磁盘的物理属性决定了节点的大小和数量
-内存访问：约100纳秒
-磁盘访问：约10毫秒 = 10,000,000纳秒
-磁盘读取的单位是"页"（通常4KB）
-无论读取1个字节还是4KB，磁盘IO时间几乎相同所以一次IO应该读取尽量多的有用数据
-节点A（5.2KB） → 第一次IO读4KB不完整;第二次IO读剩下的1.2KB（效率低下）
-对于N个关键字，如何设计树结构，使得最坏情况下的磁盘IO次数最少：假设有k各关键字---得到关键字的取值范围
```
```
数据库系统的可靠性要求：
-原子性：每次IO必须完整读取一个节点
-一致性：节点数据必须完整无误
-性能：避免多次IO读取同一个节点
如果节点超过页大小，会破坏所有这些保证
节点大小 ≤ 磁盘页大小
```
- 节点大小固定≈磁盘页大小，确保每次读取效率一致
- 无论插入顺序如何，B树都能自动保持平衡B树都会自动调整成平衡结构
- 多路分支（直接把这种树结构显式地存储起来，并优化为多叉树来适应磁盘特性）
```
二分查找 vs 多路查找
B树通过插入时的分裂规则，自动把"二分查找过程中会访问的中间点"提前提取出来，组织成显式的索引结构
```
- B树：物理存储的树结构，直接存储分隔点，一次读取多个比较信息(局部性原理：相关数据在同一个节点，一次IO读取多个关键字)

2. B树关键字排序：关键字有序分隔
```
节点结构：[key1, key2]  
子节点：   C0   C1   C2
C0中的关键字 < key1
C1中的关键字在 key1 和 key2 之间  
C2中的关键字 > key2
```
3. 分裂规则
```
第1步：找中间位置
第2步：根据索引的位置找到中间关键字然后提升中间关键字(注意中间关键索引位置floor(index/2)(数组的中间索引)的规则是向下取整)
第3步：分裂成两个子节点
关键规则：总是提升中间索引的关键字到父节点，剩下的平分给两个子节点
```
4. 四大核心定理
```
定理1：多路平衡定理
"通过适当选择分支因子m，可以在常数层数内存储任意大规模数据集"
定理2：IO复杂度定理
"B树的搜索、插入、删除操作的时间复杂度为O(log_m N)，其中磁盘IO次数为O(log_m N)"
定理3：自平衡定理
"通过节点分裂与合并操作，B树能在动态更新中自动保持平衡"
定理4：空间利用率定理
"B树的空间利用率始终保持在50%以上
数据结构应该适应底层硬件特性
不同的存储层次需要不同的优化策略
```

5. b树本身
- 层次结构
```
根节点（level 0）
    |
内部节点（level 1）← 这里的子节点可能还有子节点！// 只有内部节点才有子节点
    |
叶子节点（level 2）
```
- 处理子节点
```
-B树分裂的核心原则：保持关键字与子节点的对应关系；每个关键字都充当"分隔符"的角色；
-因为B树的分裂必须是完整的子树分裂，而不仅仅是关键字的分裂
当分裂一个内部节点时，我们需要：
    分裂关键字
    重新分配子节点（关键！）
    保持树结构的完整性
如果不处理子节点，分裂后的节点就无法正确指向下一层，树结构就断裂
-原节点的子节点公平分配给两个新节点，保持树的连通性
```
```
通用的分配公式：保证平衡分配，无论k是奇数还是偶数
midIndex = floor(k/2)
左节点:
- 关键字数 = midIndex
- 子节点数 = midIndex + 1
右节点:  
- 关键字数 = k - midIndex - 1
- 子节点数 = k - midIndex
```

- 向上生长规律
```
B树是递归结构：
根节点有子节点（第一层子节点）
子节点可能还有自己的子节点（第二层，即"孩子的孩子"）
```
- 切片原理
```
左节点 = keys[0 到 midIndex-1]      // 中间关键字之前的部分
提升关键字 = keys[midIndex]          // 正中间的关键字  
右节点 = keys[midIndex+1 到 最后]    // 中间关键字之后的部分
```



### 代码实现
```
class BTreeNode {
    constructor(order) {
        this.order = order;        // B树的阶数最大子节点数m，最小子节点数m/2
        this.keys = [];           // 存储关键字的数组，当前节点的关键字
        this.children = [];       // 存储子节点的数组，本身属性是字节点指针
        this.isLeaf = true;       // 是否是叶子节点
    }
    
    // 判断节点是否已满
    isFull() {
        return this.keys.length >=this.order-1 ;每个节点最多几个关键字
    }
    // 判断节点关键字是否过少；每个节点至少⌈m/2⌉-1个关键字 
    isMin() {
        return this.keys.length <=this.order/2-1;
    }
}

//关键字查找：多路比较之后找到第一个大于或等于key的索引的位置
findKey(key) {
    let i = 0;
    // 找到第一个大于或等于key的位置//磁盘IO的优化
    while (i < this.keys.length && key > this.keys[i]) {
        i++;
    }
    return i;  // 返回关键字应该插入的索引i
}
//插入逻辑：B树的生长是向上生长
insert(key) {
    if (this.root.isFull()) {  // 检查根节点是否已满
        //分裂根节点，创建新根
        const newRoot = new BTreeNode(this.order);
        newRoot.children.push(this.root);  // 原根成为子节点
        this._splitChild(newRoot, 0, this.root);  // 分裂原根
        this.root = newRoot; //更新根指针
    }
    this._insertNonFull(this.root, key);
}

//分裂逻辑
_splitChild(parent, index, child) {
    // 参数说明 ✓ 正确
    // parent: 要分裂的节点的父节点
    // index: child在parent.children中的位置  
    // child: 实际要分裂的节点
    const midIndex = Math.floor(child.keys.length / 2);
    const midKey = child.keys[midIndex];  // 找出中间值 
    
    // 创建右节点
    const rightNode = new BTreeNode(this.order);
    
    // === 右边部分 ===
    rightNode.keys = child.keys.slice(midIndex + 1);  // 右节点获得中间关键字之后的所有关键字 
    if (!child.isLeaf) {
        // 如果原节点有子节点，右节点也需要继承对应的子节点
        rightNode.children = child.children.slice(midIndex + 1);  //从mid+1开始取到最后
        rightNode.isLeaf = false;  // 标记右节点为内部节点 
    }
    // === 左边部分 ===  
    // 更新左节点（原来的child变成左节点）
    child.keys = child.keys.slice(0, midIndex);  // 左节点保留中间关键字之前的所有关键字 
    if (!child.isLeaf) {
        // 左节点保留对应的子节点
        child.children = child.children.slice(0, midIndex + 1);  // 从索引0开始取到mid+1
    }
    // === 更新父节点 ===
    parent.keys.splice(index, 0, midKey);  // 在父节点的index位置插入中间关键字 
    parent.children.splice(index + 1, 0, rightNode);  // 在父节点的index+1位置插入右节点 
}

```